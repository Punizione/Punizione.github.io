<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 编程杂谈(2)---Java有向图单源最短路径之Dijkstra算法 · Punizione's Blog</title><meta name="description" content="编程杂谈(2)---Java有向图单源最短路径之Dijkstra算法 - Delitto"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Punizione's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/links/" target="_self" class="nav-list-link">LINKS</a></li><li class="nav-list-item"><a href="https://github.com/Punizione" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">编程杂谈(2)---Java有向图单源最短路径之Dijkstra算法</h1><div class="post-info">2017年11月27日</div><div class="post-content"><p>前面说到了使用 <code>Serializable</code> 序列化来做有向图单源最短路径问题(Single Source Shortest Paths)中的路径复制问题,这次来说说处理最短路径的算法— <code>Dijkstra</code><br><a id="more"></a></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>为了解决有向图的单元最短路径问题,我们先来定义一些结构,当然,不使用额外定义的结构,只是用数组来表示点,边,图也是可以的,这里为了方便理解就使用结构  </p>
<p>首先是图的边类 <code>EdgeVector</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EdgeVector</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">EdgeVector</span>&gt;,<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> weight;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  start  有向边起点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  end    有向边终点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  weight 权重</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>        </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EdgeVector</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">double</span> weight)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">weight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">end</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(EdgeVector that)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.weight() &lt; that.weight())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.weight() &gt; that.weight())&#123;</span><br><span class="line">            <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"%d-&gt;%d (%.2f)"</span>, start, end, weight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现 <code>Comparable</code> 是为了方便对两条边进行权重比较  </p>
<p>同时注意到,这里用了整型来表示顶点,这么做也是为了方便理解,在给出的一个图G中,每个顶点由特有的定点编号确定,这里就不采用英文字母作为编号了  </p>
<p>其次,是图的类 <code>GraphVector</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphVector</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> V;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> E;</span><br><span class="line">    <span class="keyword">private</span> MyBag&lt;EdgeVector&gt;[] adj;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(value=&#123;<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GraphVector</span><span class="params">(<span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.V = V;</span><br><span class="line">        <span class="keyword">this</span>.E = <span class="number">0</span>;</span><br><span class="line">        adj = (MyBag&lt;EdgeVector&gt;[]) <span class="keyword">new</span> MyBag[<span class="keyword">this</span>.V];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V;i++)&#123;</span><br><span class="line">            adj[i] = <span class="keyword">new</span> MyBag&lt;EdgeVector&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(value=&#123;<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GraphVector</span><span class="params">(BufferedReader reader)</span></span>&#123;</span><br><span class="line">        String lineTxt;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>((lineTxt = reader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.V = Integer.parseInt(lineTxt);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"文件输入格式不规范"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((lineTxt = reader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.E = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            adj = (MyBag&lt;EdgeVector&gt;[])<span class="keyword">new</span> MyBag[V];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V;i++)&#123;</span><br><span class="line">                adj[i] = <span class="keyword">new</span> MyBag&lt;EdgeVector&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>((lineTxt = reader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                String[] temp = lineTxt.split(<span class="string">" "</span>);</span><br><span class="line">                <span class="keyword">this</span>.addEdge(<span class="keyword">new</span> EdgeVector(Integer.parseInt(temp[<span class="number">0</span>]), Integer.parseInt(temp[<span class="number">1</span>]), Double.parseDouble(temp[<span class="number">2</span>])));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">V</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">E</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.E;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(EdgeVector e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = e.start();</span><br><span class="line">        adj[start].add(e);</span><br><span class="line">        E++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;EdgeVector&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> adj[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;EdgeVector&gt; <span class="title">edges</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MyBag&lt;EdgeVector&gt; bag = <span class="keyword">new</span> MyBag&lt;EdgeVector&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;V;v++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(EdgeVector temp:adj[v])&#123;</span><br><span class="line">                bag.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> EdgeVector <span class="title">getEdge</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        EdgeVector edge = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(EdgeVector temp:adj[start])&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.end() == end)&#123;</span><br><span class="line">                edge  = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">            edge = <span class="keyword">new</span> EdgeVector(-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(edge==<span class="keyword">null</span>)&#123;</span><br><span class="line">            edge = <span class="keyword">new</span> EdgeVector(-<span class="number">1</span>,-<span class="number">1</span>,Double.POSITIVE_INFINITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> edge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>图的实现主要使用了背包 <code>Bag</code> 的数组来保存图中的所有边,也可以使用二维数组的,但是数组的长度不好确定,所以这里我就用了 <code>Bag</code>  </p>
<p>用来保存边集的背包类 <code>Bag</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBag</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    Node&lt;T&gt; first;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBag</span><span class="params">()</span></span>&#123;</span><br><span class="line">        first = <span class="keyword">new</span> Node&lt;T&gt;();</span><br><span class="line">        length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBag</span><span class="params">(T[] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        <span class="keyword">for</span>(T temp:array)&#123;</span><br><span class="line">            <span class="keyword">this</span>.add(<span class="keyword">new</span> Node&lt;T&gt;(temp));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node&lt;T&gt; node)</span></span>&#123;</span><br><span class="line">        node.next = first.next;</span><br><span class="line">        first.next = node;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">        Node&lt;T&gt; node = <span class="keyword">new</span> Node&lt;T&gt;(data);</span><br><span class="line">        node.next = first.next;</span><br><span class="line">        first.next = node;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//  return this.first.next==null;</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.length==<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node&lt;T&gt; current = first.next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (current != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">            T data = current.data;</span><br><span class="line">            current = current.next;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuffer str = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        Node&lt;T&gt; p = first;</span><br><span class="line">        <span class="keyword">while</span>(p.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            str.append(p.next.toString()+<span class="string">" "</span>);</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了方便以后在别的地方使用 <code>Bag</code> 类,这里用了泛型实现,而且实现了 <code>Iterable</code> 接口进行迭代,这是为了方便在对定起点的边进行搜索时进行迭代</p>
<p>注意到 <code>Bag</code> 的实现还使用了 <code>Node</code> , <code>Node</code>表示节点,可以在很多题目上使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Object</span>&gt;</span>&#123;</span><br><span class="line">    T data;</span><br><span class="line">    Node&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.next =<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>+<span class="keyword">this</span>.data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此,实现 <code>Dijkstra</code> 所需要的结构都有了<br>我也把代码放到Github上了,需要的自取</p>
<h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>首先把图的点V集分成两个集合A,B  </p>
<p>A表示已经在最短路径里面的顶点,初始化包含起点<br>B表示不在最短路径里面的顶点,即V-A  </p>
<p>循环开始, 每次把集合A与集合B中相连的边按递增次序获取, 取到最短的边,并将终点从B中删除,加入到A中,<br>每次增加新的边后要刷新一遍A,因为可能出现<code>v0 -&gt; v1</code>的权重比<code>v0 -&gt; v2 -&gt; v1</code>大的情况  </p>
<p>如此循环反复,最终得到的便是单源到图其他顶点的最短路径  </p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">class Dijkstra&#123;</span><br><span class="line">    //无限大</span><br><span class="line">    public static double INFINITY = Double.POSITIVE_INFINITY;</span><br><span class="line">    //表示由起点(start)到各个点的最短路径的权重</span><br><span class="line">    private double[] weight;</span><br><span class="line">    //保存由起点(start)到各个点的最短路径边</span><br><span class="line">    private ArrayList&lt;EdgeVector&gt;[] path;</span><br><span class="line"></span><br><span class="line">    private int start;</span><br><span class="line">    private int end;</span><br><span class="line">    //因为使用了泛型数组的初始化</span><br><span class="line">    //编译器会报&quot;未经检查的类型警告&quot;</span><br><span class="line">    @SuppressWarnings(value=&#123;&quot;unchecked&quot;&#125;)</span><br><span class="line">    public Dijkstra(GraphVector g,int start,int end)&#123;</span><br><span class="line">        //初始化</span><br><span class="line">        this.start = start;</span><br><span class="line">        this.end = end;</span><br><span class="line">        weight = new double[g.V()];</span><br><span class="line">        for(int i=0;i&lt;g.V();i++)&#123;</span><br><span class="line">            weight[i] = INFINITY;</span><br><span class="line">        &#125;</span><br><span class="line">        weight[start] = 0.0;</span><br><span class="line">        for(EdgeVector temp:g.adj(start))&#123;</span><br><span class="line">            weight[temp.end()] = temp.weight();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        path = (ArrayList&lt;EdgeVector&gt;[])new ArrayList[g.V()];</span><br><span class="line">        for(int i=0;i&lt;g.V();i++)&#123;</span><br><span class="line">            path[i] = new ArrayList&lt;EdgeVector&gt;();</span><br><span class="line">            if(g.getEdge(start,i).weight()&lt; INFINITY)&#123;</span><br><span class="line">                //把起点 与 起点可达连通的点 形成的边保存为最短路径</span><br><span class="line">                path[i].add(g.getEdge(start,i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean[] hasFindPath = new boolean[g.V()];</span><br><span class="line">        for(int i=0;i&lt;g.V();i++)&#123;</span><br><span class="line">            hasFindPath[i] = false;</span><br><span class="line">        &#125;</span><br><span class="line">        hasFindPath[start] = true;</span><br><span class="line"></span><br><span class="line">        //开始循环</span><br><span class="line">        int v = -1;</span><br><span class="line">        for(int i=0;i&lt;g.V();i++)&#123;</span><br><span class="line">            double min = INFINITY;</span><br><span class="line">            for(int j=0;j&lt;g.V();j++)&#123;</span><br><span class="line">                if( !hasFindPath[j] )&#123;</span><br><span class="line">                    if(weight[j] &lt; min)&#123;</span><br><span class="line">                        v = j;</span><br><span class="line">                        min = weight[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            hasFindPath[v] = true;</span><br><span class="line">        </span><br><span class="line">            for(int j = 0;j&lt;g.V();j++)&#123;</span><br><span class="line">                if(!hasFindPath[j] &amp;&amp; (g.getEdge(v,j).weight() &lt; INFINITY) &amp;&amp; (min+g.getEdge(v,j).weight() &lt; weight[j]))&#123;</span><br><span class="line">                    weight[j] = min+g.getEdge(v,j).weight();</span><br><span class="line">                    try&#123;</span><br><span class="line">                        //这里采用的是深拷贝</span><br><span class="line">                        //实现方式见类DeepCopy</span><br><span class="line">                        path[j] = (ArrayList&lt;EdgeVector&gt;)DeepCopy.copyBySerialize(path[v]);</span><br><span class="line">                    &#125;catch(Exception e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    path[j].add(g.getEdge(v,j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void getShortestPath()&#123;</span><br><span class="line">        System.out.println(start+&quot;到&quot;+end+&quot;最短路径:&quot;);</span><br><span class="line">        for(EdgeVector temp:path[end])&#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;长度:&quot;);</span><br><span class="line">        System.out.printf(&quot;%.3f&quot;,weight[end]);</span><br><span class="line">    &#125;</span><br><span class="line">    public void getShortestPath(int end)&#123;</span><br><span class="line">        System.out.println(start+&quot;到&quot;+end+&quot;最短路径:&quot;);</span><br><span class="line">        for(EdgeVector temp:path[end])&#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;长度:&quot;);</span><br><span class="line">        System.out.printf(&quot;%.3f&quot;,weight[end]);      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此,<code>Dijkstra</code>的 <del>复杂化</del> 实现就完成了(。Д。 ；)  </p>
<p><img src="./css/images/55527150_p0_master1200.jpg" alt="jpg"></p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/11/25/talk1/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">Delitto</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>