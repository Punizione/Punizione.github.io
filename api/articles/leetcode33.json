{"title":"LeetCode 33","slug":"leetcode33","date":"2017-11-30T02:13:19.346Z","updated":"2017-12-14T14:19:15.386Z","comments":true,"excerpt":"<p>今天的Leetcode突然抽风,直接访问会跳出Google的机器验证<br>搭梯子的话直接不用验证就进去了…","content":"<p>今天的Leetcode突然抽风,直接访问会跳出Google的机器验证<br>搭梯子的话直接不用验证就进去了…<a id=\"more\"></a></p>\n<p><a href=\"https://leetcode.com/problems/search-in-rotated-sorted-array/description/\" target=\"_blank\" rel=\"external\">Search in Rotated Sorted Array</a></p>\n<h2 id=\"原题目\"><a href=\"#原题目\" class=\"headerlink\" title=\"原题目\"></a>原题目</h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>\n<p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>\n<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>\n<p>You may assume no duplicate exists in the array.</p>\n<h2 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h2><p>给定一个升序排序好的数组,但是其在某个位置进行了前后置换  </p>\n<p>比如原先是<code>int[]{0,1,2,4,5,6,7}</code>  </p>\n<p>置换后成了<code>int[]{4,5,6,7,0,1,2}</code></p>\n<p>现在要求在这个数组里查找一个数</p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>第一反应应该还是二分查找,毕竟是最快的  </p>\n<p>但是这个位置置换了的点有点难以确认,如果对数组进行重排序的话就失去了二分查找的性能优势 </p>\n<p>思考过后,觉得可以这样:</p>\n<p>首先还是二分:<br>令另<code>low = 0, high = array.length</code>,接下来,原本应该判断<code>array[(low+high)/2]</code>与所给的需要查找的数<code>target</code>的大小关系  </p>\n<p>但这里就额外多一个步骤,令一个临时变量<code>num</code>来保存<code>array[(low+high)/2]</code>  </p>\n<p>首先判断<code>num</code>与<code>target</code>是否都在一个升序序列里  </p>\n<p>因为置换后的数组大概可以看成这样:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   /</span><br><span class=\"line\">  /</span><br><span class=\"line\"> /    </span><br><span class=\"line\">/</span><br><span class=\"line\">      /</span><br><span class=\"line\">     /</span><br><span class=\"line\">    /</span><br></pre></td></tr></table></figure>\n<p>如果在一个升序序列里的话,说明<code>num</code>的值可以用来与<code>target</code>比较从而进行二分</p>\n<p>如果不在呢?</p>\n<p>不在的话就分成了两种情况:</p>\n<ul>\n<li><code>num</code>在值较小的序列里,<code>target</code>在值较大的序列里</li>\n<li><code>num</code>在值较大的序列里,<code>target</code>在值较小的序列里</li>\n</ul>\n<p>先考虑第一种情况<br><code>num</code>在值较小的序列里,<code>target</code>在值较大的序列里<br>这说明<code>num</code>的值比<code>target</code>小,那么<code>num</code>作为<code>array[(low+high)/2]</code>应该往值较大的那个序列搜,也就是<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">high = mid;</span><br><span class=\"line\">mid = (low+high)/<span class=\"number\">2</span>;</span><br><span class=\"line\">num = array[mid]</span><br></pre></td></tr></table></figure></p>\n<p>第二种情况也同理</p>\n<p>所以总体的代码如下<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> lo = <span class=\"number\">0</span>,hi = nums.length;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(lo&lt;hi)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mid = (lo+hi)/<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num = (nums[mid]&lt;nums[<span class=\"number\">0</span>])==(target&lt;nums[<span class=\"number\">0</span>])?nums[mid]:</span><br><span class=\"line\">                                                    (target&lt;nums[<span class=\"number\">0</span>]?Integer.MIN_VALUE:</span><br><span class=\"line\">                                                       Integer.MAX_VALUE);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(num &lt;target)&#123;</span><br><span class=\"line\">        lo = mid+<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(num&gt;target)&#123;</span><br><span class=\"line\">        hi = mid;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure></p>\n<p>可想而知的Accepted了…</p>\n<p>令我大跌眼镜的是<br><em>最快的方法竟然是一个循环从头到尾判断！！！</em></p>\n","thumbnail":["http://p0s30qphu.bkt.clouddn.com/17-12-11/30812780.jpg"],"primarycolor":"orange","accentcolor":"lime","categories":[{"name":"编程","path":"api/categories/编程.json"}],"tags":[{"name":"算法","path":"api/tags/算法.json"},{"name":"LeetCode","path":"api/tags/LeetCode.json"},{"name":"Java","path":"api/tags/Java.json"}]}