<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Delitto&#39;s Blog</title>
  
  <subtitle>挣扎中的人</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://delitto.top/"/>
  <updated>2017-12-18T09:26:11.433Z</updated>
  <id>https://delitto.top/</id>
  
  <author>
    <name>Delitto</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>优秀的爬虫工程师都是不用Python的</title>
    <link href="https://delitto.top/2017/12/18/talk7/"/>
    <id>https://delitto.top/2017/12/18/talk7/</id>
    <published>2017-12-18T07:18:32.000Z</published>
    <updated>2017-12-18T09:26:11.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="向神文致敬"><a href="#向神文致敬" class="headerlink" title="向神文致敬"></a>向神文致敬</h2><p>本文参考了：<br><a href="https://zhuanlan.zhihu.com/p/32084230" target="_blank" rel="external">优秀的程序员是不用机械键盘的</a><br><a href="https://zhuanlan.zhihu.com/p/32097488" target="_blank" rel="external">优秀的程序员都是不用 IDE 的</a><br><a href="https://zhuanlan.zhihu.com/p/32108926" target="_blank" rel="external">优秀的垃圾佬都是不用固态硬盘的</a></p><p>原文章:<br><a href="https://zhuanlan.zhihu.com/p/31956362" target="_blank" rel="external">优秀的女孩是没有性生活的</a></p><h2 id="优秀的爬虫工程师都是不用Python的"><a href="#优秀的爬虫工程师都是不用Python的" class="headerlink" title="优秀的爬虫工程师都是不用Python的"></a>优秀的爬虫工程师都是不用Python的</h2><p>前几天我测试一个想做爬虫的师弟，连续几个专业问题他都没答上来。  </p><p>尴尬之余，我问他：你没有什么理想吗？你现在最渴望的事情是什么？</p><p>男孩转悠着大眼睛，不假思索道：「用Python写爬虫！」</p><p>真没想到在测试中居然还有这种操作。  </p><p>我问为什么这能成为现阶段最渴望的事情，他反问「你就没有心情浮躁的夜晚吗？寂寞长夜，总想用用Python，爽一下自己啊。」  </p><p>好有道理我竟无法反驳。  </p><p>这么能说会道的师弟，一定是个不可多得的人才！  </p><p>于是，我决定：拉黑这个人。</p><p>这几年，在Github和StackOverflow闯来闯去，原本内向型人格的我，做事风格也逐渐变得风风火火，在高强度快节奏下像个工作机器，不带一丝情感绝对执行工作计划。  </p><p>无论是BAT这样大公司，还是一些小的数据公司，这两个圈子的爬虫大佬几乎个个都能独当一面，久而久之，我认识了太多优秀的爬虫工程师，然后，我发现一个残酷的共同点————  </p><p>他们都不用Python。  </p><p>不会Python吗？一个个做机器学习各种模型各种训练，还有Django，Flask各种Web框架建站平均流量几十万。  </p><p>不喜欢脚本语言吗？他们Lua、Groovy、Perl、Ruby玩得飞起。</p><p>我问过其中一个爬虫工程师，问：你渴望用Python写爬虫吗？  </p><p>他说：废话，肯定渴望啊。</p><p>我问：为什么不用呢？公司不肯？</p><p>他叹气：不，太忙。</p><p>他意味深长道：<strong>优秀的爬虫工程师都不用Python的。</strong></p><p>跟我聊天的这个人，本身就是个大神，大学里两年修完了四年CS的学分，提前实习去做了搜索引擎，连教授都感到惊叹。毕业后，在求职之余，他还独立做出了个数据平台，令面试官大为震动。  </p><p>他先去美国读研，在湾区工作了几年，回国后，并没有拿家里的钱，拿着在美国工作存下的积蓄，自己跑到北京创业。  </p><p>最开始半年，几乎把钱都赔光了，死咬着牙不跟家里说，又死要面子不肯跟朋友借，他拿信用卡贷款，终于在又一个半年后，转亏为盈。  </p><p>他还从来没放弃过抢着收集双12的天猫数据。  </p><p>这样的爬虫工程师，Python大概就是随便用。  </p><p>我还认识一个大佬。  </p><p>他是那种手写XPath，一看页面就知道对应的div的id是什么的那种。这几年来，他的所有爬虫代码，包括数据清洗，分析都是用汇编写出来的。  </p><p>爬虫工程师这个圈子，大多数人都苦苦挣扎，能写到他这个程度的，基本上出场就是千万QPS，压根不像传统的意义上大家印象里的Bug制造者。  </p><p>然而这个大佬却是爬虫工程师里面的一股清流。  </p><p>他最大的爱好便是在家里学习新的技术，<code>import torch</code>，<code>#include &quot;GL/glus.h&quot;</code>，活得像是不会Python的人。</p><p>程序员这个行业，只有走到金字塔塔尖才可以任性，他也一样，在圈子有时候身不由己，会在奇葩产品精力的要求下写一个脑残功能。  </p><p>同为IT产业的人，在面对市场仍是庸俗当道的大环境时，绝大多数人都被迫无奈去用一些误以为能提高工作效率的类似于Scrapy、PySpider、requests的库，久而久之，人都会变得浮躁。  </p><p>他却不会受到影响。  </p><p>我问他：你到底怎么保持一颗平常心的，别人都用Python来写爬虫，你怎么能如此潇洒地用汇编和Basic写，不会干扰到你的内心？  </p><p>他笑，说，你小时候没写过作文啊？尤其是学校组织的那种征文？  </p><p>我立刻懂了。</p><p><strong>即使是不喜欢的东西，也可以用专业态度去应对，在适度妥协的同时，依旧保持自己本真的创作。</strong>  </p><p>就好比算法竞赛的时候，我们都会几套不同版本的API，获得竞赛的成绩以保证不被学校、老师训斥后，依旧会在自己的电脑上用自己想用的版本。  </p><p><strong>这种本真，不是每个人都能坚持的，尤其是在出社会后，看尽繁华世界依旧不骄不躁，分得清妥协和执着的度，是非常难得的。</strong>  </p><p>他在写完爬虫后，依旧在默默的等待着数据一条一条被抓取下来，实在令人钦佩。  </p><p>像他这样仿佛活成仙的爬虫工程师，对于Python，肯定不会有着庸俗的期待，他知道他会遇见怎么样的需求和怎么样的库，所以，他不着急。  </p><p>我希望你明白，<strong>爬虫工程师的价值从来都是由他的数据体现，而非由Python。</strong>  </p><p>上周跟朋友吃饭，他说他认识的一些刚入门的爬虫工程师，总会认为没必要太累去拼搏，应该多花点时间去学习Python。  </p><p>他跟我说，「可你不一样，你会一直提醒我，要我远离舒适区，要我不能把问题归咎在Python上，要我有危机意识，你好像特别看重不用Python写爬虫。」  </p><p><strong>人都是需要独立的。</strong></p><p><strong>仍是要永远年轻，永远热泪盈眶。</strong></p><p><strong>仍是要时时刻刻对美好满怀期待，对未来充满渴望，对经典心怀敬畏。</strong></p><p>要记住啊，<strong>知世故而不世故，处江湖而远江湖，才是最善良的成熟。</strong></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本文纯属瞎编，我自己都编不下去了，写原文的人是怎么想到把一堆毫无关系的文字和感想凑到一起的。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;向神文致敬&quot;&gt;&lt;a href=&quot;#向神文致敬&quot; class=&quot;headerlink&quot; title=&quot;向神文致敬&quot;&gt;&lt;/a&gt;向神文致敬&lt;/h2&gt;&lt;p&gt;本文参考了：&lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32084230&quot; 
      
    
    </summary>
    
      <category term="闲聊" scheme="https://delitto.top/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="牢骚" scheme="https://delitto.top/tags/%E7%89%A2%E9%AA%9A/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 80</title>
    <link href="https://delitto.top/2017/12/14/Leetcode80/"/>
    <id>https://delitto.top/2017/12/14/Leetcode80/</id>
    <published>2017-12-14T02:08:57.129Z</published>
    <updated>2017-12-14T14:22:16.619Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/" target="_blank" rel="external">Remove Duplicates from Sorted Array II</a></p><h2 id="原题目"><a href="#原题目" class="headerlink" title="原题目"></a>原题目</h2><p>Follow up for “Remove Duplicates”:<br>What if duplicates are allowed at most twice?</p><p>For example,<br>Given sorted array nums = [1,1,1,2,2,3],</p><p>Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn’t matter what you leave beyond the new length.</p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个排好序的整型数组，要求经过调用方法后，原数组中的元素最多出现2次。  </p><p>也就是把原数组里所有多次两次的元素减少到2次，这样的话数组有效长度会变短，此时不考虑原数组比起变短后多出来的那部分的元素  </p><p>比如给了[1,1,1,2,2,3]  </p><p>调用后就应该是[1,1,2,2,3,X]  </p><p>这里X就无关是什么数  </p><p>另外这个方法需要返回调用方法后数组的实际长度，按上面的例子就应该返回5</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>乍一看可以用暴力的题我都试着暴力一下</p><p>首先需一个变量<code>length</code>，保存实际长度<br>然后需要一个变量<code>count</code>，记录当前的元素出现过多少次<br>然后再需要一个变量<code>now</code>，记录当前元素<br>再然后需要一个数组<code>res</code>，保存消除掉第三个及以上的重复元素后剩下的其他元素<br>用一个<code>for</code>循环，从第二个元素开始，比较当前元素与<code>now</code>  </p><p>一样的话则<code>count</code>计数器自增，然后判断<code>count</code>是不是仍小于2，若小于2，则说明该元素可以放进<code>res</code>里面，将该元素放进去</p><p>若不一样，则<code>count</code>计数器重置，<code>now</code>重置，将该元素放入<code>res</code></p><p>最终得到的<code>res</code>再使用System.arraypocy全部复制到<code>nums</code>中<br>返回<code>res</code>的索引下标</p><p>代码应该是这样的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> now = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">    res[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;    </span><br><span class="line">        <span class="keyword">if</span>(now==nums[i])&#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(count&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">                res[j++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            now = nums[i];</span><br><span class="line">            res[j++] = nums[i];</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">              </span><br><span class="line">    &#125;</span><br><span class="line">    System.arraycopy(res,<span class="number">0</span>,nums,<span class="number">0</span>,res.length-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一种蠢方法，无论怎么看都觉得很蠢，浪费大把空间在一个O(n)的问题上</p><p>于是考虑更好的方法</p><p>注意到这个原数组是排好序的，如果按题目要求进行替换<br>最终的结果应该满足一个条件:<br><strong>若<code>i&gt;2，nums[i]&gt;nums[i-2]</code></strong><br><strong>若<code>i&lt;=2</code>，则无论如何都不会出现超过两个数是相同的，因为<code>i&lt;2</code>就说明现在数组里只有两个元素</strong></p><p>知道这个规律就好办多了</p><p>只需要用一个变量：<code>index</code>来表示数组下标就可以了<br>思路想好了，代码就容易得多：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n:nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">2</span>||n&gt;nums[i-<span class="number">2</span>])&#123;</span><br><span class="line">            nums[i++] = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用for-each就能很方便地对数组迭代</p><p>在164个测试用例中<br>平均Runtime 从<code>2ms</code>减少到了<code>1ms</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Remove Duplica
      
    
    </summary>
    
      <category term="编程" scheme="https://delitto.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法" scheme="https://delitto.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://delitto.top/tags/LeetCode/"/>
    
      <category term="Java" scheme="https://delitto.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>近况</title>
    <link href="https://delitto.top/2017/12/12/talk6/"/>
    <id>https://delitto.top/2017/12/12/talk6/</id>
    <published>2017-12-12T13:59:43.000Z</published>
    <updated>2017-12-14T14:22:02.888Z</updated>
    
    <content type="html"><![CDATA[<h2 id="我傻逼了"><a href="#我傻逼了" class="headerlink" title="我傻逼了"></a>我傻逼了</h2><p>上上一篇博文刚给这个域名上了https，今天又给博客配了个图床，却没注意到极简图床这玩意不支持https，搞得<code>delitto.top</code>这个域名又变成了<code>not secure</code>状态，原因自然是<img src="http://p0s30qphu.bkt.clouddn.com/17-12-12/48331494.jpg" alt="res">  </p><p>祸不单行，前几天还说<code>.top</code>域名国内不用实名认证，今天阿里云的客服打电话给我，跟我说这个域名要实名，不然就挂。  </p><p>我还好奇怎么回事，一上域名后台管理，发现原来的<a href="https://bbs.aliyun.com/read/322733.html?spm=a21av.7663099.1998408794.10.28269f9ef0VQ3u" target="_blank" rel="external">公告</a>上不动声色地多加了一条关于<code>.top</code>域名的规则，大体意思就是要我实名认证之类的。  </p><p>想必是方便 <del>抓人</del> 监管吧2333</p><h2 id="近况"><a href="#近况" class="headerlink" title="近况"></a>近况</h2><p>今天双十二了，离春招还有不到4个月时间  </p><p>我开始担忧起自己的出路  </p><p>像是“考前焦虑症”</p><p>大概罗列了一下：</p><p>这两年做完的和正在做的东西:</p><ul><li>软设的Android App---不是我一个人做完的</li><li>软设的纯Servlet后台---不是我一个人做完的</li><li>学校教务系统的信息爬虫---现在因为学校不开放外网已经废掉了</li><li>所有学生身份证和手机号的爬虫---怕被查水表也不敢怎么抓</li><li>天猫京东价格趋势的爬虫---天猫页面更替反复不知道能撑多久</li><li>基于OpenCV的图像识别---啃不下《机器视觉》这本书</li><li>LeetCode刷到 129/711  Easy80 Medium42 Hard7</li><li>Android App锁–卡在界面还没做完</li><li>基于Lua的弹幕游戏---弹幕还没设计好</li><li>Java图书荐购系统后台---拿来当SSM整合练手的</li><li>Tornado的微信小程序后台---拿来学PythonWeb练手的</li><li>加利福尼亚州的两个V2服务端---如果不是怕查水表的话可以租给别人赚钱了</li><li>为了应对DNS污染而自搭的基于TCP的DNS---效果一般，VPS回收了</li><li>给师姐做毕设—前端做了两个<a href="https://delitto.com.cn/example/index.html" target="_blank" rel="external">页面</a></li><li>做完了<a href="https://www.v2ray.com/" target="_blank" rel="external">Project V</a>的其中一个Android小部件<br>还有些自己都忘了的小东西，全是<code>Python</code>和<code>Lua</code>，然而自主完成的东西大都是因为某些原因 <del>BigBrotherIsWatchingYou</del> 不能放上台面来讲的</li></ul><p>算是会了的知识：</p><ul><li>Java基础</li><li>Python2基础</li><li>JSP，Servlet</li><li>大概的网络协议，KCP</li><li>姑且算是会了的基础数据结构和各种基础算法<br>#没了#</li></ul><p>而只懂个皮毛的：</p><ul><li>各种框架</li><li>各种原理<br>上面两个东西占了现在脑子的80%</li></ul><p>一向是接受得了就接受，接受不了就算的心态</p><p>遇到大部分问题姑且还能自己解决，也算是有些许自学能力，也就这么过着吧</p><p>寒假也想着准备春招，姑且就这样先学着吧</p><p>晚上开始早睡了 <del>虽然被吵得睡不着</del>，大概是冬天来了的原因</p><p>也开始会认真听课了，因为发现GPA还是有点用的</p><p>简历还是要投一投的，说不定脸好呢</p><h2 id="Live2D插件"><a href="#Live2D插件" class="headerlink" title="Live2D插件"></a>Live2D插件</h2><p>给博客加了个Live2D插件</p><p>效果看右下角就好了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;我傻逼了&quot;&gt;&lt;a href=&quot;#我傻逼了&quot; class=&quot;headerlink&quot; title=&quot;我傻逼了&quot;&gt;&lt;/a&gt;我傻逼了&lt;/h2&gt;&lt;p&gt;上上一篇博文刚给这个域名上了https，今天又给博客配了个图床，却没注意到极简图床这玩意不支持https，搞得&lt;code&gt;d
      
    
    </summary>
    
      <category term="闲聊" scheme="https://delitto.top/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="hexo" scheme="https://delitto.top/tags/hexo/"/>
    
      <category term="牢骚" scheme="https://delitto.top/tags/%E7%89%A2%E9%AA%9A/"/>
    
  </entry>
  
  <entry>
    <title>博客的各种操作-续</title>
    <link href="https://delitto.top/2017/12/12/fitment2/"/>
    <id>https://delitto.top/2017/12/12/fitment2/</id>
    <published>2017-12-12T03:57:02.000Z</published>
    <updated>2017-12-14T14:21:47.187Z</updated>
    
    <content type="html"><![CDATA[<p>成功使用<code>Material Design</code>的<code>theme</code>–<a href="https://github.com/EYHN/hexo-theme-one/tree/master" target="_blank" rel="external">ONE</a>替换原先的<a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank" rel="external">apollo</a><code>theme</code><a id="more"></a></p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p><code>hexo</code>的其中一个很方便的地方就在于可以很自由地更换主题，使得个人博客的个性化趋于简单。  </p><p>之前使用<code>apollo</code>是看中了这个<code>theme</code>的简约，对我来说，一个博客能够记录自己的学习笔记和平时发发牢骚就够了，<code>apollo</code>从各个方面都很贴合的我的需求，所以一开始我便选择了这个<code>theme</code>。</p><p>被吐槽没有排版之后就考虑换了，换什么呢？</p><p>很快我就想到了<code>Google</code>的<code>Material Design</code>的设计风格，果然在<code>theme</code>商店一搜就有很多，挑了这个比较中意的<code>ONE</code>的这个<code>theme</code>。</p><p>文档写得很明白就不在这里多赘述，作者是<a href="https://github.com/EYHN" target="_blank" rel="external">滑稽</a></p><p>最后博客的成果图是这样的<br><img src="http://p0s30qphu.bkt.clouddn.com/17-12-12/41517972.jpg" alt="res"></p><h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><p>鉴于现在在用的博客是托管在<code>Github</code>上的，空间肯定不多，遂想用个个人空间储存博客需要用到的图片。  </p><p>最后我选择了<a href="http://jiantuku.com/" target="_blank" rel="external">极简图床</a>，它使用的空间服务是<a href="https://www.qiniu.com" target="_blank" rel="external">七牛云</a>，据极简图床文档所述，采用的是<a href="https://sm.ms/" target="_blank" rel="external">SM.MS</a>的API。</p><p>知道这些后，首先去七牛云注册帐号，个人实名认证，可以得到10G免费空间，按极简图床的教程，把图床的API网址和<code>Access Key</code>和<code>Public Key</code>配置好，就可以上传图片到图床使用了。  </p><p>把所有图片上传后，可以得到图片专属链接(公开)</p><p><img src="http://p0s30qphu.bkt.clouddn.com/17-12-12/93766709.jpg" alt="pic">  </p><p>把原先博客的所有图片地址都替换成图床的图片地址，大功告成。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;成功使用&lt;code&gt;Material Design&lt;/code&gt;的&lt;code&gt;theme&lt;/code&gt;–&lt;a href=&quot;https://github.com/EYHN/hexo-theme-one/tree/master&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ONE&lt;/a&gt;替换原先的&lt;a href=&quot;https://github.com/pinggod/hexo-theme-apollo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;apollo&lt;/a&gt;&lt;code&gt;theme&lt;/code&gt;
    
    </summary>
    
      <category term="hexo" scheme="https://delitto.top/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://delitto.top/tags/hexo/"/>
    
      <category term="图床" scheme="https://delitto.top/tags/%E5%9B%BE%E5%BA%8A/"/>
    
      <category term="MaterialDesign" scheme="https://delitto.top/tags/MaterialDesign/"/>
    
  </entry>
  
  <entry>
    <title>博客的各种操作</title>
    <link href="https://delitto.top/2017/12/10/fitment/"/>
    <id>https://delitto.top/2017/12/10/fitment/</id>
    <published>2017-12-10T12:42:52.000Z</published>
    <updated>2017-12-14T14:21:30.117Z</updated>
    
    <content type="html"><![CDATA[<p>最近可能会考虑把博客换个<code>theme</code>，现在的<code>theme</code>是<a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank" rel="external">apollo</a>，然后就被吐槽说没有排版… </p><p>好吧既然如此我就换个<code>Material Design</code>的<code>theme</code>吧<a id="more"></a></p><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><p>怎么说呢  </p><p>感觉一直用<code>Github</code>的<code>Github Page</code>也不是很cool<br>所以就想着给博客 <del>上个buff</del> 加个个人域名</p><p>在<a href="https://uk.godaddy.com/" target="_blank" rel="external"><code>Godaddy</code></a>上逛了几圈之后觉得略贵..转向国内阿里的<a href="https://wanwang.aliyun.com/" target="_blank" rel="external">万网</a></p><p>选了个域名<code>delitto.top</code>  首付两块续费十六  </p><p>顺带一提，<code>.net .com .cn</code>域名在国内需要实名认证和备案不然不能用<br><code>.top</code>的话就没有这种限制</p><p>买好域名之后，在个人中心里面配置好DNS解析，万网会默认给你配两个国内的DNS地址，这里就不用管  </p><p>添加一条IPv4解析和一条CNAME解析<br><img src="http://p0s30qphu.bkt.clouddn.com/17-12-11/5981637.jpg" alt="res"></p><p>CNAME指向的是博客的<code>Github Page</code>的域名<code>xxx.github.io</code><br>IPv4指向的就是该域名的IP了，可以通过<code>ping xxx.github.io</code>来确定</p><p>配置好后，等几分钟，访问<code>delitto.top</code>就能得到结果了</p><h2 id="给个人域名上HTTPS"><a href="#给个人域名上HTTPS" class="headerlink" title="给个人域名上HTTPS"></a>给个人域名上HTTPS</h2><p>做完上面之后会发现，原先的<code>Github Page</code>本身有自带https，这是<code>Github</code>给你配的，但是如果我们使用个人域名的话，https就没了</p><p>这时就要考虑给个人域名上https了，毕竟国内网络环境复杂，中间人劫持什么的都有，上个https还是很有必要的  </p><p>但是问题来了</p><p>虽然域名有了，但是现在用的服务器还是<code>Github</code>的，如果租个服务器的话就要考虑在国内各种备案各种申请，怪麻烦的，而且总觉得 <del>老大哥在看着你</del> 不是很有安全感<br>当然了国外的就没这么多限制，但是血贵</p><p>有没有对<code>Github</code>托管的个人域名上https的方法？</p><p>有的，就是<a href="https://www.cloudflare.com" target="_blank" rel="external">CloudFlare</a>，这个服务商可以给你上一个半程的https，当你访问的时候，到CloudFlare是https，由CloudFlare去解析和访问你的博客是http，虽然是半程的但是对于个人博客来说也够了，这个操作需要把你的域名的解析商改成CloudFlare提供的解析商</p><p>注册之后会让你绑定一个域名，针对这个域名选一个套餐，选免费的那个就可以了，功能足够使用</p><p>进去之后设置DNS，把之前在万网的DNS设置copy到CloudFlare的DNS，然后把去万网把DNS服务商改成CloudFlare给你的DNS</p><p>然后在CloudFlare的<code>Crypto</code>开启<code>Always use HTTPS</code>，这个选项可以让访问http的自动跳转到https</p><h2 id="HSTS"><a href="#HSTS" class="headerlink" title="HSTS"></a>HSTS</h2><p>然后视个人情况开启<code>HTTP Strict Transport Security (HSTS)</code>，<code>HSTS</code>是啥呢，简单来说就是安全..，因为上面的<code>Always use HTTPS</code>设置，我们访问http站点的时候，服务器会通过304跳转到https站点，这时如果在http访问阶段就被中间人劫持，中间人完全可以伪造我们与服务器的https链接，这样的话https就形同虚设了  </p><p>如果能在一开始浏览器检测到http的时候自动访问https，这样就不会有访问到服务器然后304的可能了，这时就需要开启<code>HSTS</code>，就需要的话把所有开关都打开，并把<code>max-age</code>调到1年，这样<code>HSTS</code>就设置完毕</p><p>关于<code>HSTS</code>的更多详细可以参考这篇<a href="http://www.jianshu.com/p/caa80c7ad45c" target="_blank" rel="external">文章</a></p><p>经过上述步骤后，可以把我们的域名加入到<code>HSTS</code>的<code>Preload List</code>里面了，<code>Preload List</code>是什么呢？</p><p>简单来说，<code>HSTS</code>还有个问题，就是哦我们的第一次访问总是且只能是http的，因为浏览器并不确定网站有没有开启https，通过一次304跳转后才知道，“哦这个网站有https，且在一年内都会用https”，如果在首次http访问的时候就已经被中间人劫持了，那后面的https就无从说起了</p><p>所以我们需要<code>Preload List</code>，这个东西记录了哪些网站有https，我们开启<code>Preload List</code>后，可以去<code>HSTS</code><a href="https://hstspreload.org/" target="_blank" rel="external">官网</a>测试一下我们的域名了，测试通过后就会把我们的域名加入到<code>Preload List</code>里面了，这需要几天的时间</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近可能会考虑把博客换个&lt;code&gt;theme&lt;/code&gt;，现在的&lt;code&gt;theme&lt;/code&gt;是&lt;a href=&quot;https://github.com/pinggod/hexo-theme-apollo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;apollo&lt;/a&gt;，然后就被吐槽说没有排版… &lt;/p&gt;
&lt;p&gt;好吧既然如此我就换个&lt;code&gt;Material Design&lt;/code&gt;的&lt;code&gt;theme&lt;/code&gt;吧
    
    </summary>
    
      <category term="hexo" scheme="https://delitto.top/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://delitto.top/tags/hexo/"/>
    
      <category term="https" scheme="https://delitto.top/tags/https/"/>
    
      <category term="域名" scheme="https://delitto.top/tags/%E5%9F%9F%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 59</title>
    <link href="https://delitto.top/2017/12/09/LeetCode59/"/>
    <id>https://delitto.top/2017/12/09/LeetCode59/</id>
    <published>2017-12-09T04:15:54.451Z</published>
    <updated>2017-12-14T14:21:14.164Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/spiral-matrix-ii/description/" target="_blank" rel="external">Spiral Matrix II</a></p><h2 id="原题目"><a href="#原题目" class="headerlink" title="原题目"></a>原题目</h2><p>Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.</p><p>For example,<br>Given n = 3,</p><p>You should return the following matrix:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 8, 9, 4 ],</span><br><span class="line"> [ 7, 6, 5 ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个整数n，求该边长为n的顺时针螺旋方阵</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>一道思绪比动手重要的题，不知道为什么我首先想到是递归 (´・ω・`)</p><p>瞎做了几个钟后未果，遂静下来慢慢想</p><p>这道题应该按着数字增长的角度来做，也就是说一次只要考虑向着一个方向自增就可以</p><p>所以应该有<code>left,right,up,down</code>四个指针，用来标识当前应该赋值的指针走的最大边界，用一个循环来不停地自增</p><p>那循环的停止条件是什么呢？<br>可以是当边界左指针<code>left</code>与边界右指针<code>right</code>相遇的时候，说明赋值已经到达了方阵中心了，当然了也可以是边界上指针<code>up</code>与下指针<code>down</code>相遇的时候，这个不影响</p><p>所以代码应该是这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span>[][] ret = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>,up = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = n -<span class="number">1</span>,down = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = left; j &lt;= right; j ++) &#123;</span><br><span class="line">            ret[up][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        up ++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = up; i &lt;= down; i ++) &#123;</span><br><span class="line">            ret[i][right] = count ++;</span><br><span class="line">        &#125;</span><br><span class="line">        right --;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = right; j &gt;= left; j --) &#123;</span><br><span class="line">            ret[down][j] = count ++;</span><br><span class="line">        &#125;</span><br><span class="line">        down --;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = down; i &gt;= up; i --) &#123;</span><br><span class="line">            ret[i][left] = count ++;</span><br><span class="line">        &#125;</span><br><span class="line">        left ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下：<br><img src="http://p0s30qphu.bkt.clouddn.com/17-12-11/44283747.jpg" alt="res"></p><h2 id="变体"><a href="#变体" class="headerlink" title="变体"></a>变体</h2><p>这道题如果有逆时针旋转的变体,只需要把<code>left,right,up,down</code>这四个指针的变换方向换一下就可以了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/spiral-matrix-ii/description/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Spiral Matrix II&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;原题目
      
    
    </summary>
    
      <category term="编程" scheme="https://delitto.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法" scheme="https://delitto.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://delitto.top/tags/LeetCode/"/>
    
      <category term="Java" scheme="https://delitto.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>关于ZUN在直播中提到的二次创作规约的看法</title>
    <link href="https://delitto.top/2017/12/07/touhou/"/>
    <id>https://delitto.top/2017/12/07/touhou/</id>
    <published>2017-12-07T11:16:17.681Z</published>
    <updated>2017-12-14T14:20:52.373Z</updated>
    
    <content type="html"><![CDATA[<p>12月2号的时候ZUN在直播的时候公布了一些二次创作的规约和关于一些Steam的问题。<br>其中提到了二次创作作品在Steam上发布的问题，并对此做了一些约定。<a id="more"></a>  </p><p>不管怎么说，我本人还是很期待看到这样的事发生的。出于对东方这个圈子的热爱，我也始终认为二设这种东西应该好好管管，而不是当一个新人来到的时候，因为分不清什么是二设什么是一设而瞎扯。国内的东方圈子近几年 <del>智障</del> 脑回路不正常的人多了起来，以一种幼稚无比的态度对待这个本该是很欢乐的圈子，而Steam圈就更乱了，可以说各种互为利益的人都有，所以一开始听说新作要上Steam并开放的时候我是很怕的，ZUN本人也表示了这种担忧：</p><blockquote><p>亚洲东方的粉丝非常多，大家可能有兴趣在Steam上出游戏。<br>这个部分我其实是有点害怕的，希望大家谨慎一点，不要做的太过分。</p></blockquote><p>言下之意是什么呢？可能有很多人为了利益等一方面因素，挂着东方的名号恶意捞钱或者蹭热度，这种事国内也不是没发生过，有一次在漫展就有不知道哪来的穿得跟 <del>妓女</del> 一样的自称COS灵梦的bitch，吸引许多人的关注，而这位所谓的COSer本人居然还恬不知耻地说她也不清楚，淘宝卖COS服的是这么跟她说的…</p><h2 id="关于条约"><a href="#关于条约" class="headerlink" title="关于条约"></a>关于条约</h2><p>条约的具体可以去<a href="https://thwiki.cc/%E5%85%B3%E4%BA%8E%E4%B8%9C%E6%96%B9%E4%BA%8C%E6%AC%A1%E5%88%9B%E4%BD%9C%E6%B8%B8%E6%88%8F%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%8F%91%E5%B8%83" target="_blank" rel="external">这里</a>看,至于对条约的各种解释可以看看<a href="https://weibo.com/ttarticle/p/show?id=2309404180661635279506" target="_blank" rel="external">这个</a>  </p><p>本来我还在担心，如果东方开放了Steam这个渠道，如何鉴定什么情况是二设，什么情况是抄袭，什么情况是侵权，如果解释权在G胖手里的话，G胖一封律师函发过去，这对整个同人圈的毁灭性是巨大的。  </p><p>但从如今看来，这个条约可以说是对当今的东方二次同人开发者和整个同人产业都有极大的帮助，可以说是历史性的一步。</p><p>对于官作，我一直的态度就是“你敢上我就敢买”，但是对于同人，我还是不怎么敢像对官作那样抱着很期待的态度的，但是像夏夜祭那样的极度的优秀的作品，我是很希望在Steam上能看到它的身影的，而制作组也已经放出消息，新作《东方雪莲华》确定在Steam上发售，这无疑是个好消息</p><p>国内STG圈子本来就小，都是靠一群dalao在撑着，基本上属于那种萌新进了就被游戏劝退的或者只限于打打easy的这种现状，而ZUN这个决定无疑是帮助圈外的人更容易理解和接纳STG这个小众又不失为一种乐趣的娱乐方式</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;12月2号的时候ZUN在直播的时候公布了一些二次创作的规约和关于一些Steam的问题。&lt;br&gt;其中提到了二次创作作品在Steam上发布的问题，并对此做了一些约定。
    
    </summary>
    
      <category term="闲聊" scheme="https://delitto.top/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="牢骚" scheme="https://delitto.top/tags/%E7%89%A2%E9%AA%9A/"/>
    
      <category term="东方" scheme="https://delitto.top/tags/%E4%B8%9C%E6%96%B9/"/>
    
  </entry>
  
  <entry>
    <title>说说《正义联盟》</title>
    <link href="https://delitto.top/2017/12/04/justice/"/>
    <id>https://delitto.top/2017/12/04/justice/</id>
    <published>2017-12-04T12:07:08.155Z</published>
    <updated>2017-12-14T14:20:20.828Z</updated>
    
    <content type="html"><![CDATA[<p>我自认为也算半个DC粉丝，而正联这部电影也是被众多DC粉寄与厚望的电影，但是从电影本身的表现来看，我们也不想承认的是，它没有如期地回应大部分粉丝的期望，但这是无可奈何的事，且不说电影拍到一半导演<a href="http://www.imdb.com/name/nm0811583/" target="_blank" rel="external">扎克施奈德</a>就因为女儿自杀而退出，导致华纳与DC不得不更换风格完全不同的导演<a href="http://www.imdb.com/name/nm0923736/" target="_blank" rel="external">乔斯·韦登</a>的事，单从剧情的设定上来说，剧情把大超设定得太强，导致战斗画面不可避免的只是单方面的碾压，看完整场电影下来，大部分人感觉就是:”一开始复活超人就没这么多事了”<br>当然，这篇东西并不是什么影评，不过是个人的一些牢骚，就不谈多么专业的东西。<br><a id="more"></a></p><h2 id="关于电影"><a href="#关于电影" class="headerlink" title="关于电影"></a>关于电影</h2><p>emmm电影风格我只能说还过得去，完整看完下来，对于上面两位导演不太熟悉人可能感觉不到什么风格的差距，但是从贴吧知乎豆瓣等影评看下来的话，大部分粉丝对电影的叙事与描绘风格还是给出了“有风格撕裂、感觉前后相差好大”的评价.  </p><p>编剧为了照顾没有了解过的观众，特意在很多地方都加了“单纯只是为了解释而解释”的对话，比如女侠第一次用真言套索的时候，说到<a href="http://dc.wikia.com/wiki/Mother_Box" target="_blank" rel="external">母盒</a>的时候，说到<a href="http://dc.wikia.com/wiki/Steppenwolf" target="_blank" rel="external">荒原狼</a>的时候，但这也是编剧妥协的结果  </p><p>从对位上看，《正联》这部电影对的是漫威同一时期的《雷神3》，但是《雷神3》比起《正联》来说，至少观众们都挺熟悉雷神、洛基、浩克这些在以往MCU里面出场过的人气角色，<br>《正联》就没这么好运气了，神奇女侠好歹前面还有拍过一部个人电影，小闪至少美剧已经到了第四季了，相比之下，海王和钢骨就需要剧情里面更多的细节来塑造人物形象了.</p><p>从《BVS》的一些彩蛋可以看出，DC的电影宇宙是想做得很大的，而且很大可能是想要往《不义联盟》那个方向走的，但是从《正联》这部电影的表现来看，DC还是把眼光放得太遥远了，可能是华纳两个小时的限制限制住了导演剪辑的方案，也可能是漫威这几年电影宇宙的大火让DC着急了，总之，这部电影对我来说远达不到我印象中应该有的《正义联盟》的样子  </p><p>作为一个希望DC和漫威平等地扳手腕的不起眼的粉丝，我是很希望DC能在其电影宇宙上做出让观众都满意的作品，狠狠地出一口恶气 <del>，抽漫威一个耳光</del></p><h2 id="关于人物"><a href="#关于人物" class="headerlink" title="关于人物"></a>关于人物</h2><p>人物表现特别尴尬，首先是 <strong>神奇女侠戴安娜</strong> ，作为一个强大、性感、无所畏惧、本电影唯一一个出场带<a href="http://music.163.com/#/song?id=405079658" target="_blank" rel="external">BGM</a>、战斗毫不犹豫、<a href="http://manhua.dmzj.com/buyilianmen/42505.shtml#@page=17" target="_blank" rel="external">不义漫画</a>里能和超人打个55开的人，在电影里的表现….却只能靠队友的衬托来凸显她的强大….</p><p>我都不好意思跟非粉丝说她多么牛逼多么牛逼…<br>当然，可能是编剧为了凸显女侠在正联里面除去超人和蝙蝠侠之外仅剩的 <strong>领导能力</strong> ，就削弱了她在战斗方便的表现…. <del>强行找台阶下</del> </p><p>接下来是 <strong>小闪–闪电侠巴里艾伦</strong> …小闪人气在DC中算是比较高的了，而在非粉丝眼里是这个世界上跑得最快的人了，但是在电影里面表现却是速度被超人追上了，这点其实是漫画原著有特意提及的，DC漫画历史上闪电侠和超人有过多次比试速度，讲道理嘛还是小闪更快那么一些(待考证)，小闪另外一个奇怪的点是 <strong>经常各种摔</strong>，海王都在剧中吐槽”这个人总是摔，没用”  </p><p>如果说这部电影里小闪的存在是为了活跃气氛，那么上面那些就能说得通了，搞笑嘛 _(:3 」∠)_ </p><p>至于 <strong>海王亚瑟·库瑞，也叫水行侠</strong>…，漫画中他是不是个人气角色不好说，但电影里面就是个气人角色.通篇下来，海王就干了这么些事:</p><ul><li>嘲讽蝙蝠侠</li><li>在海里打不过荒原狼</li><li>挡不住水 <del>拜托，你是“海王”耶</del></li><li>偷了蝙蝠侠桌子上的东西</li><li>被超人一拳打飞</li><li>被荒原狼一拳打趴</li><li>超人摩擦荒原狼的时候在旁边说了句”Nice” </li></ul><p>超蝙就不说了，超人太强，强到其他五个人一起上都被秒，蝙蝠侠太弱，弱到打个小兵都费劲，漫画里本该有智商也没表现出来 <del>不说没有已经很给面子了</del></p><h2 id="关于彩蛋"><a href="#关于彩蛋" class="headerlink" title="关于彩蛋"></a>关于彩蛋</h2><p>彩蛋嘛还是蛮多的，但可能不是粉丝的会get不到点</p><ul><li>比如讲诉荒原狼的历史时候出现的绿灯侠，看到他的时候我还以为绿灯侠会在电影里正式出现，然而并没有…  而且这个绿灯侠后面还直接被荒原狼一斧头砍死了</li><li>同样是讲诉原狼的历史时候出现的希腊众神之王宙斯(戴安娜他爹)，就是用雷电把三个母盒分开的那个，还有阿特米斯(希腊女神)</li><li>闪电侠的父亲的演员是DC另外一部史诗级电影《Watch Man》(《守望者》)里面的曼哈顿博士的扮演者</li><li>蝙蝠侠第一次到小闪的家里是，闪电侠说“我还会猩猩语”，这是在说闪电侠的对手-大猩猩格鲁得，在漫画和美剧里闪电侠都有和格鲁得交流过</li><li>超人复活后黑化抓住蝙蝠侠问他”Do you bleed?(你会流血吗)”，这是《BVS》里面蝙蝠侠抓着超人的时候问他的…在这里超人又反问了蝙蝠侠，然后蝙蝠侠还打趣地说”好吧我确实会流血”</li><li>荒原狼在得到两个母盒后说了一句”for unity， for Darkseid”(为了统一，为了达克赛德)，国语翻译就直接把Darkseid直译成”黑暗君主”了，我个人还是比较喜欢”达克赛德”这个比较霸气的翻译的，而漫画里荒原狼是达克赛德的舅舅，很忠心于达克赛德，以后达克赛德也肯定会出场</li><li>最后蝙蝠侠准备盖正义大厅的时候说要准备六把椅子，神奇女侠说不止六把，暗示以后绿灯侠可能出现</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我自认为也算半个DC粉丝，而正联这部电影也是被众多DC粉寄与厚望的电影，但是从电影本身的表现来看，我们也不想承认的是，它没有如期地回应大部分粉丝的期望，但这是无可奈何的事，且不说电影拍到一半导演&lt;a href=&quot;http://www.imdb.com/name/nm0811583/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;扎克施奈德&lt;/a&gt;就因为女儿自杀而退出，导致华纳与DC不得不更换风格完全不同的导演&lt;a href=&quot;http://www.imdb.com/name/nm0923736/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;乔斯·韦登&lt;/a&gt;的事，单从剧情的设定上来说，剧情把大超设定得太强，导致战斗画面不可避免的只是单方面的碾压，看完整场电影下来，大部分人感觉就是:”一开始复活超人就没这么多事了”&lt;br&gt;当然，这篇东西并不是什么影评，不过是个人的一些牢骚，就不谈多么专业的东西。&lt;br&gt;
    
    </summary>
    
      <category term="电影" scheme="https://delitto.top/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="电影" scheme="https://delitto.top/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="牢骚" scheme="https://delitto.top/tags/%E7%89%A2%E9%AA%9A/"/>
    
      <category term="DC" scheme="https://delitto.top/tags/DC/"/>
    
  </entry>
  
  <entry>
    <title>编程杂谈(5)---输出自身的程序</title>
    <link href="https://delitto.top/2017/12/03/talk5/"/>
    <id>https://delitto.top/2017/12/03/talk5/</id>
    <published>2017-12-03T01:42:26.412Z</published>
    <updated>2017-12-14T14:20:05.797Z</updated>
    
    <content type="html"><![CDATA[<p>发现个很好玩的东西,像是脑筋急转弯 <a id="more"></a></p><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>无意在网上发现一道说是美国高中生的编程练习题  </p><p>写一个程序,这个程序的执行结果这是在控制台输出这个程序本身的代码,<br>当然了,代码不能为空,也不能是异常信息(有些语言的异常信息可以等同于代码信息)</p><p>一开始我以为很简单,用<code>Java</code>试了几下都没成,遂放弃换成<code>Python</code></p><p>早该意识到解释型语言应该比编译型语言更适合用来做这道题</p><p>果不其然,<code>Python</code>只要两句话就行了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'s = %r\nprint(s%%s)'</span></span><br><span class="line">print(s%s)</span><br></pre></td></tr></table></figure><p>那Java该怎么办?</p><p>或者说编译型、强类型的该怎么办?</p><p>多次尝试未果,遂Google搜搜</p><p>知道了这叫做<a href="https://en.wikipedia.org/wiki/Quine" target="_blank" rel="external">Quine</a></p><p>而Java版的代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quine</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> q = <span class="number">34</span>;      <span class="comment">// Quotation mark character</span></span><br><span class="line">    String[] l = &#123;    <span class="comment">// Array of source code</span></span><br><span class="line">    <span class="string">"public class Quine"</span>,</span><br><span class="line">    <span class="string">"&#123;"</span>,</span><br><span class="line">    <span class="string">"  public static void main(String[] args)"</span>,</span><br><span class="line">    <span class="string">"  &#123;"</span>,</span><br><span class="line">    <span class="string">"    char q = 34;      // Quotation mark character"</span>,</span><br><span class="line">    <span class="string">"    String[] l = &#123;    // Array of source code"</span>,</span><br><span class="line">    <span class="string">"    "</span>,</span><br><span class="line">    <span class="string">"    &#125;;"</span>,</span><br><span class="line">    <span class="string">"    for(int i = 0; i &lt; 6; i++)           // Print opening code"</span>,</span><br><span class="line">    <span class="string">"        System.out.println(l[i]);"</span>,</span><br><span class="line">    <span class="string">"    for(int i = 0; i &lt; l.length; i++)    // Print string array"</span>,</span><br><span class="line">    <span class="string">"        System.out.println(l[6] + q + l[i] + q + ',');"</span>,</span><br><span class="line">    <span class="string">"    for(int i = 7; i &lt; l.length; i++)    // Print this code"</span>,</span><br><span class="line">    <span class="string">"        System.out.println(l[i]);"</span>,</span><br><span class="line">    <span class="string">"  &#125;"</span>,</span><br><span class="line">    <span class="string">"&#125;"</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)           <span class="comment">// Print opening code</span></span><br><span class="line">        System.out.println(l[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l.length; i++)    <span class="comment">// Print string array</span></span><br><span class="line">        System.out.println(l[<span class="number">6</span>] + q + l[i] + q + <span class="string">','</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">7</span>; i &lt; l.length; i++)    <span class="comment">// Print this code</span></span><br><span class="line">        System.out.println(l[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不得不佩服dalao们对程序逻辑的理解之深 _(:3 」∠)_</p><p>后来问了部落的一个做前端的,他表示用<code>JavaScript</code>很容易就能写得出来<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.write(a, <span class="string">"a()"</span>);</span><br><span class="line">&#125;</span><br><span class="line">a()</span><br></pre></td></tr></table></figure></p><p>emmmmmm…….<br>_(:3 」∠)_</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;发现个很好玩的东西,像是脑筋急转弯
    
    </summary>
    
      <category term="编程" scheme="https://delitto.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="https://delitto.top/tags/Java/"/>
    
      <category term="学习笔记" scheme="https://delitto.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>编程杂谈(4)---三路快速排序</title>
    <link href="https://delitto.top/2017/12/02/talk4/"/>
    <id>https://delitto.top/2017/12/02/talk4/</id>
    <published>2017-12-02T10:34:21.121Z</published>
    <updated>2017-12-14T14:19:51.656Z</updated>
    
    <content type="html"><![CDATA[<p>上次说到快排的优化,同时对快排的几种可能会造成排序效率变慢的情况进行了优化,但仍然存在一个问题。  <a id="more"></a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>当待排序数组里存在多个相同的值时,使用普通的快速排序仍然效率很慢,因为左右指针都有可能停在和基准值相同的值上,这种问题在数组里面存在多个相同值时更为突出  </p><p>而使用随机选取的方式也不一定能够规避这个问题,因为当相同的值越来越多时,随机选取选择到该值的机率很增大,变相降低了排序效率</p><p>考虑一种方式:<br>能不能使用第三个指针<code>cur</code>,令于基准值相同的值分布到汇集到基准值位置  </p><p>这样的话就相当于在进行快排的同时对对大量相同的数据排序了</p><p><img src="http://p0s30qphu.bkt.clouddn.com/17-12-11/32202558.jpg" alt="example"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>修改原有的<code>partition(int[], int, int)</code>方法,增加一个变量<code>cur</code>记录相同的基准值<br>修改返回值为<code>int[]</code>,表示相同的基准值开始和结束的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[left];</span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="keyword">int</span> j = right;</span><br><span class="line">    <span class="keyword">int</span> cur = i;</span><br><span class="line">    <span class="keyword">while</span>(cur&lt;=j)&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[cur]&gt;temp) &#123;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[cur]&lt;temp) &#123;</span><br><span class="line">            swap(arr, cur++, i++);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            swap(arr, cur, j--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i - <span class="number">1</span>, j + <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用的时候就这样<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] ret = partition(arr, left, right);</span><br><span class="line">qSort(arr, left, ret[<span class="number">0</span>]);</span><br><span class="line">qSort(arr, ret[<span class="number">1</span>], right);</span><br></pre></td></tr></table></figure></p><p>至此,三路优化的快速排序完成</p><p><img src="http://p0s30qphu.bkt.clouddn.com/17-12-11/28678657.jpg" alt="pic"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上次说到快排的优化,同时对快排的几种可能会造成排序效率变慢的情况进行了优化,但仍然存在一个问题。
    
    </summary>
    
      <category term="编程" scheme="https://delitto.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法" scheme="https://delitto.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://delitto.top/tags/Java/"/>
    
      <category term="学习笔记" scheme="https://delitto.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>编程杂谈(3)---Java快速排序优化</title>
    <link href="https://delitto.top/2017/12/01/talk3/"/>
    <id>https://delitto.top/2017/12/01/talk3/</id>
    <published>2017-12-01T04:44:18.673Z</published>
    <updated>2017-12-14T14:19:33.731Z</updated>
    
    <content type="html"><![CDATA[<p>今天部落里一个dalao去唯品面试实习生,然后被要求手撕快排233333<a id="more"></a></p><h2 id="普通の快排"><a href="#普通の快排" class="headerlink" title="普通の快排"></a>普通の快排</h2><p>快排的思路是基于递归,选定一个元素作为基点,令左边的都小于该元素,右边的都大于该元素,如此递归.</p><p>样例代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] newArray = arr.clone();</span><br><span class="line">    qSort(newArray,<span class="number">0</span>,newArray.length-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">qSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="keyword">int</span> pivotloc = partition(arr,low,high);</span><br><span class="line">        qSort(arr,low,pivotloc-<span class="number">1</span>);</span><br><span class="line">        qSort(arr,pivotloc+<span class="number">1</span>,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j&amp;&amp;temp&lt;=arr[j])&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j &amp;&amp;temp&gt;arr[i])&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">            arr[j] = arr[i];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i] = temp;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以发现,每次选取的元素都是在固定的位置,当待排序的数据趋于有序时,很容易造成这个递归栈变得很深,这样的话会使得快排的时间复杂度由<code>O(log(n))</code>上升到<code>O(n^2)</code>,失去了性能优势.</p><h2 id="随机选取の快排"><a href="#随机选取の快排" class="headerlink" title="随机选取の快排"></a>随机选取の快排</h2><p>考虑采用随机选取基点的方式进行优化.</p><p>样例代码如下:<br>在<code>partition(int[], int, int)</code>方法里对基准的选择进行更改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[((<span class="keyword">int</span>)(Math.random()*(j-i+<span class="number">1</span>)+i))];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j&amp;&amp;temp&lt;=arr[j])&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j &amp;&amp;temp&gt;arr[i])&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">            arr[j] = arr[i];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i] = temp;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样的话就相当于把待排序的所有情况都等同于乱序了,对“接近乱序的数组”的排序性能可能会稍微下降..</p><h2 id="插入排序×快速排序"><a href="#插入排序×快速排序" class="headerlink" title="插入排序×快速排序"></a>插入排序×快速排序</h2><p>考虑到快速排序的递归性,当待排序数组很小时,递归完全就是降低性能拖慢速度了,所以可以考虑在数组小于一定规模时,换另外一种排序方式提高性能.</p><p>这里就采用插入排序</p><p>样例代码如下:<br>修改<code>qSort(int[], int, int)</code>方法,当<code>high-low</code>小于一定的值时改用插入排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">qSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="keyword">if</span>(high-low &lt;= k)&#123;</span><br><span class="line">            insertSort(arr, low, high);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pivotloc = partition(arr, low, high);</span><br><span class="line">        qSort(arr, low, pivotloc-<span class="number">1</span>);</span><br><span class="line">        qSort(arr, pivotloc+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertSort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=low+<span class="number">1</span>;i&lt;=high;i++)&#123;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        <span class="keyword">for</span>(j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>&amp;&amp;temp&lt;arr[j];j--)&#123;</span><br><span class="line">            arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此,<del>简单的</del> 快速排序优化就完成了,下次讲讲接着进行更为复杂的优化方式</p><p>代码已push到Github上,需要自取~</p><p><img src="http://p0s30qphu.bkt.clouddn.com/17-12-11/93454669.jpg" alt="35678607"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天部落里一个dalao去唯品面试实习生,然后被要求手撕快排233333
    
    </summary>
    
      <category term="编程" scheme="https://delitto.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法" scheme="https://delitto.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://delitto.top/tags/Java/"/>
    
      <category term="学习笔记" scheme="https://delitto.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 33</title>
    <link href="https://delitto.top/2017/11/30/leetcode33/"/>
    <id>https://delitto.top/2017/11/30/leetcode33/</id>
    <published>2017-11-30T02:13:19.346Z</published>
    <updated>2017-12-14T14:19:15.386Z</updated>
    
    <content type="html"><![CDATA[<p>今天的Leetcode突然抽风,直接访问会跳出Google的机器验证<br>搭梯子的话直接不用验证就进去了…<a id="more"></a></p><p><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/description/" target="_blank" rel="external">Search in Rotated Sorted Array</a></p><h2 id="原题目"><a href="#原题目" class="headerlink" title="原题目"></a>原题目</h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p><p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p><p>You may assume no duplicate exists in the array.</p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个升序排序好的数组,但是其在某个位置进行了前后置换  </p><p>比如原先是<code>int[]{0,1,2,4,5,6,7}</code>  </p><p>置换后成了<code>int[]{4,5,6,7,0,1,2}</code></p><p>现在要求在这个数组里查找一个数</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>第一反应应该还是二分查找,毕竟是最快的  </p><p>但是这个位置置换了的点有点难以确认,如果对数组进行重排序的话就失去了二分查找的性能优势 </p><p>思考过后,觉得可以这样:</p><p>首先还是二分:<br>令另<code>low = 0, high = array.length</code>,接下来,原本应该判断<code>array[(low+high)/2]</code>与所给的需要查找的数<code>target</code>的大小关系  </p><p>但这里就额外多一个步骤,令一个临时变量<code>num</code>来保存<code>array[(low+high)/2]</code>  </p><p>首先判断<code>num</code>与<code>target</code>是否都在一个升序序列里  </p><p>因为置换后的数组大概可以看成这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   /</span><br><span class="line">  /</span><br><span class="line"> /    </span><br><span class="line">/</span><br><span class="line">      /</span><br><span class="line">     /</span><br><span class="line">    /</span><br></pre></td></tr></table></figure><p>如果在一个升序序列里的话,说明<code>num</code>的值可以用来与<code>target</code>比较从而进行二分</p><p>如果不在呢?</p><p>不在的话就分成了两种情况:</p><ul><li><code>num</code>在值较小的序列里,<code>target</code>在值较大的序列里</li><li><code>num</code>在值较大的序列里,<code>target</code>在值较小的序列里</li></ul><p>先考虑第一种情况<br><code>num</code>在值较小的序列里,<code>target</code>在值较大的序列里<br>这说明<code>num</code>的值比<code>target</code>小,那么<code>num</code>作为<code>array[(low+high)/2]</code>应该往值较大的那个序列搜,也就是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">high = mid;</span><br><span class="line">mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">num = array[mid]</span><br></pre></td></tr></table></figure></p><p>第二种情况也同理</p><p>所以总体的代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lo = <span class="number">0</span>,hi = nums.length;</span><br><span class="line"><span class="keyword">while</span>(lo&lt;hi)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (lo+hi)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> num = (nums[mid]&lt;nums[<span class="number">0</span>])==(target&lt;nums[<span class="number">0</span>])?nums[mid]:</span><br><span class="line">                                                    (target&lt;nums[<span class="number">0</span>]?Integer.MIN_VALUE:</span><br><span class="line">                                                       Integer.MAX_VALUE);</span><br><span class="line">    <span class="keyword">if</span>(num &lt;target)&#123;</span><br><span class="line">        lo = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num&gt;target)&#123;</span><br><span class="line">        hi = mid;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><p>可想而知的Accepted了…</p><p>令我大跌眼镜的是<br><em>最快的方法竟然是一个循环从头到尾判断！！！</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天的Leetcode突然抽风,直接访问会跳出Google的机器验证&lt;br&gt;搭梯子的话直接不用验证就进去了…
    
    </summary>
    
      <category term="编程" scheme="https://delitto.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法" scheme="https://delitto.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://delitto.top/tags/LeetCode/"/>
    
      <category term="Java" scheme="https://delitto.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 24</title>
    <link href="https://delitto.top/2017/11/28/leetcode24/"/>
    <id>https://delitto.top/2017/11/28/leetcode24/</id>
    <published>2017-11-28T11:10:51.459Z</published>
    <updated>2017-12-14T14:18:57.664Z</updated>
    
    <content type="html"><![CDATA[<p>一道链表置换的题</p><p><a href="https://leetcode.com/problems/swap-nodes-in-pairs/description/" target="_blank" rel="external">Swap Nodes in Pairs</a></p><h2 id="原题目"><a href="#原题目" class="headerlink" title="原题目"></a>原题目</h2><p>Given a linked list, swap every two adjacent nodes and return its head.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">For example,</span><br><span class="line">Given 1-&gt;2-&gt;3-&gt;4, you should <span class="built_in">return</span> the list as 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure><p>Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.</p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个链表,返回两两置换后的链表,必须置换节点,不能置换节点的值。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>记得去年上数据结构我们老师就给我们讲过这样的题(´・ω・`)</p><p>首先在链表头增加一个首部 <code>dummy</code>,用来指定链表的第一个节点  </p><p>用一个节点引用 <code>now</code> 表明现在指针在的位置  </p><p>然后一个while循环判断<code>now</code>  </p><p>接下来两个节点是否为空,不为空的话就置换这两个节点,然后 <code>now</code> 指针往后移两个单位<br>否则就退出循环了</p><p>代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    ListNode now = dummy;</span><br><span class="line">    <span class="keyword">while</span> (now.next!=<span class="keyword">null</span> &amp;&amp; now.next.next!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode first = now.next;</span><br><span class="line">        ListNode second = now.next.next;</span><br><span class="line">        first.next = second.next;</span><br><span class="line">        now.next = second;</span><br><span class="line">        now.next.next = first;</span><br><span class="line">        now = now.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在翻看他人的答案的时候看到了一种使用递归的解法  </p><p>思路是将<code>swapPairs()</code>方法作为只处理两个节点的置换的方法  </p><p>1-&gt;2-&gt;3</p><p>2-&gt;1-&gt;3<br>这样的话使用该方法置换两个节点后,<code>节点1</code>的<code>next</code>就可以指定为<code>swapPairs(3)</code>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode second = head.next;</span><br><span class="line">    ListNode third = second.next;</span><br><span class="line"></span><br><span class="line">    second.next = head;</span><br><span class="line">    head.next = swapPairs(third);</span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路很巧妙,不失为一种可行的方式,在40多个测试用例中,平均时间和使用循环差不多</p><p>或许在一定场景下能比循环的很快吧(笑</p><p>代码我放在Github上了,需要自取~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一道链表置换的题&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/swap-nodes-in-pairs/description/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Swap Nodes in Pai
      
    
    </summary>
    
      <category term="编程" scheme="https://delitto.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法" scheme="https://delitto.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://delitto.top/tags/LeetCode/"/>
    
      <category term="Java" scheme="https://delitto.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>编程杂谈(2)---Java有向图单源最短路径之Dijkstra算法</title>
    <link href="https://delitto.top/2017/11/27/Dijkstra/"/>
    <id>https://delitto.top/2017/11/27/Dijkstra/</id>
    <published>2017-11-27T10:02:58.217Z</published>
    <updated>2017-12-14T14:18:33.483Z</updated>
    
    <content type="html"><![CDATA[<p>前面说到了使用 <code>Serializable</code> 序列化来做有向图单源最短路径问题(Single Source Shortest Paths)中的路径复制问题,这次来说说处理最短路径的算法— <code>Dijkstra</code><br><a id="more"></a></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>为了解决有向图的单元最短路径问题,我们先来定义一些结构,当然,不使用额外定义的结构,只是用数组来表示点,边,图也是可以的,这里为了方便理解就使用结构  </p><p>首先是图的边类 <code>EdgeVector</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EdgeVector</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">EdgeVector</span>&gt;,<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> weight;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  start  有向边起点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  end    有向边终点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  weight 权重</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>        </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EdgeVector</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">double</span> weight)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">weight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">end</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(EdgeVector that)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.weight() &lt; that.weight())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.weight() &gt; that.weight())&#123;</span><br><span class="line">            <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"%d-&gt;%d (%.2f)"</span>, start, end, weight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 <code>Comparable</code> 是为了方便对两条边进行权重比较  </p><p>同时注意到,这里用了整型来表示顶点,这么做也是为了方便理解,在给出的一个图G中,每个顶点由特有的定点编号确定,这里就不采用英文字母作为编号了  </p><p>其次,是图的类 <code>GraphVector</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphVector</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> V;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> E;</span><br><span class="line">    <span class="keyword">private</span> MyBag&lt;EdgeVector&gt;[] adj;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(value=&#123;<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GraphVector</span><span class="params">(<span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.V = V;</span><br><span class="line">        <span class="keyword">this</span>.E = <span class="number">0</span>;</span><br><span class="line">        adj = (MyBag&lt;EdgeVector&gt;[]) <span class="keyword">new</span> MyBag[<span class="keyword">this</span>.V];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V;i++)&#123;</span><br><span class="line">            adj[i] = <span class="keyword">new</span> MyBag&lt;EdgeVector&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(value=&#123;<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GraphVector</span><span class="params">(BufferedReader reader)</span></span>&#123;</span><br><span class="line">        String lineTxt;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>((lineTxt = reader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.V = Integer.parseInt(lineTxt);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"文件输入格式不规范"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((lineTxt = reader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.E = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            adj = (MyBag&lt;EdgeVector&gt;[])<span class="keyword">new</span> MyBag[V];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V;i++)&#123;</span><br><span class="line">                adj[i] = <span class="keyword">new</span> MyBag&lt;EdgeVector&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>((lineTxt = reader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                String[] temp = lineTxt.split(<span class="string">" "</span>);</span><br><span class="line">                <span class="keyword">this</span>.addEdge(<span class="keyword">new</span> EdgeVector(Integer.parseInt(temp[<span class="number">0</span>]), Integer.parseInt(temp[<span class="number">1</span>]), Double.parseDouble(temp[<span class="number">2</span>])));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">V</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">E</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.E;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(EdgeVector e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = e.start();</span><br><span class="line">        adj[start].add(e);</span><br><span class="line">        E++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;EdgeVector&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> adj[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;EdgeVector&gt; <span class="title">edges</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MyBag&lt;EdgeVector&gt; bag = <span class="keyword">new</span> MyBag&lt;EdgeVector&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;V;v++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(EdgeVector temp:adj[v])&#123;</span><br><span class="line">                bag.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> EdgeVector <span class="title">getEdge</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        EdgeVector edge = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(EdgeVector temp:adj[start])&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.end() == end)&#123;</span><br><span class="line">                edge  = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">            edge = <span class="keyword">new</span> EdgeVector(-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(edge==<span class="keyword">null</span>)&#123;</span><br><span class="line">            edge = <span class="keyword">new</span> EdgeVector(-<span class="number">1</span>,-<span class="number">1</span>,Double.POSITIVE_INFINITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> edge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>图的实现主要使用了背包 <code>Bag</code> 的数组来保存图中的所有边,也可以使用二维数组的,但是数组的长度不好确定,所以这里我就用了 <code>Bag</code>  </p><p>用来保存边集的背包类 <code>Bag</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBag</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    Node&lt;T&gt; first;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBag</span><span class="params">()</span></span>&#123;</span><br><span class="line">        first = <span class="keyword">new</span> Node&lt;T&gt;();</span><br><span class="line">        length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBag</span><span class="params">(T[] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        <span class="keyword">for</span>(T temp:array)&#123;</span><br><span class="line">            <span class="keyword">this</span>.add(<span class="keyword">new</span> Node&lt;T&gt;(temp));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node&lt;T&gt; node)</span></span>&#123;</span><br><span class="line">        node.next = first.next;</span><br><span class="line">        first.next = node;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">        Node&lt;T&gt; node = <span class="keyword">new</span> Node&lt;T&gt;(data);</span><br><span class="line">        node.next = first.next;</span><br><span class="line">        first.next = node;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//  return this.first.next==null;</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.length==<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node&lt;T&gt; current = first.next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (current != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">            T data = current.data;</span><br><span class="line">            current = current.next;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuffer str = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        Node&lt;T&gt; p = first;</span><br><span class="line">        <span class="keyword">while</span>(p.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            str.append(p.next.toString()+<span class="string">" "</span>);</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了方便以后在别的地方使用 <code>Bag</code> 类,这里用了泛型实现,而且实现了 <code>Iterable</code> 接口进行迭代,这是为了方便在对定起点的边进行搜索时进行迭代</p><p>注意到 <code>Bag</code> 的实现还使用了 <code>Node</code> , <code>Node</code>表示节点,可以在很多题目上使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Object</span>&gt;</span>&#123;</span><br><span class="line">    T data;</span><br><span class="line">    Node&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.next =<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>+<span class="keyword">this</span>.data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至此,实现 <code>Dijkstra</code> 所需要的结构都有了<br>我也把代码放到Github上了,需要的自取</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>首先把图的点V集分成两个集合A,B  </p><p>A表示已经在最短路径里面的顶点,初始化包含起点<br>B表示不在最短路径里面的顶点,即V-A  </p><p>循环开始, 每次把集合A与集合B中相连的边按递增次序获取, 取到最短的边,并将终点从B中删除,加入到A中,<br>每次增加新的边后要刷新一遍A,因为可能出现<code>v0 -&gt; v1</code>的权重比<code>v0 -&gt; v2 -&gt; v1</code>大的情况  </p><p>如此循环反复,最终得到的便是单源到图其他顶点的最短路径  </p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dijkstra</span></span>&#123;</span><br><span class="line">    <span class="comment">//无限大</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> INFINITY = Double.POSITIVE_INFINITY;</span><br><span class="line">    <span class="comment">//表示由起点(start)到各个点的最短路径的权重</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] weight;</span><br><span class="line">    <span class="comment">//保存由起点(start)到各个点的最短路径边</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;EdgeVector&gt;[] path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">    <span class="comment">//因为使用了泛型数组的初始化</span></span><br><span class="line">    <span class="comment">//编译器会报"未经检查的类型警告"</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(value=&#123;<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dijkstra</span><span class="params">(GraphVector g,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">        weight = <span class="keyword">new</span> <span class="keyword">double</span>[g.V()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g.V();i++)&#123;</span><br><span class="line">            weight[i] = INFINITY;</span><br><span class="line">        &#125;</span><br><span class="line">        weight[start] = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(EdgeVector temp:g.adj(start))&#123;</span><br><span class="line">            weight[temp.end()] = temp.weight();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        path = (ArrayList&lt;EdgeVector&gt;[])<span class="keyword">new</span> ArrayList[g.V()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g.V();i++)&#123;</span><br><span class="line">            path[i] = <span class="keyword">new</span> ArrayList&lt;EdgeVector&gt;();</span><br><span class="line">            <span class="keyword">if</span>(g.getEdge(start,i).weight()&lt; INFINITY)&#123;</span><br><span class="line">                <span class="comment">//把起点 与 起点可达连通的点 形成的边保存为最短路径</span></span><br><span class="line">                path[i].add(g.getEdge(start,i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] hasFindPath = <span class="keyword">new</span> <span class="keyword">boolean</span>[g.V()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g.V();i++)&#123;</span><br><span class="line">            hasFindPath[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        hasFindPath[start] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始循环</span></span><br><span class="line">        <span class="keyword">int</span> v = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g.V();i++)&#123;</span><br><span class="line">            <span class="keyword">double</span> min = INFINITY;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;g.V();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>( !hasFindPath[j] )&#123;</span><br><span class="line">                    <span class="keyword">if</span>(weight[j] &lt; min)&#123;</span><br><span class="line">                        v = j;</span><br><span class="line">                        min = weight[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            hasFindPath[v] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;g.V();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!hasFindPath[j] &amp;&amp; (g.getEdge(v,j).weight() &lt; INFINITY) &amp;&amp; (min+g.getEdge(v,j).weight() &lt; weight[j]))&#123;</span><br><span class="line">                    weight[j] = min+g.getEdge(v,j).weight();</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="comment">//这里采用的是深拷贝</span></span><br><span class="line">                        <span class="comment">//实现方式见类DeepCopy</span></span><br><span class="line">                        path[j] = (ArrayList&lt;EdgeVector&gt;)DeepCopy.copyBySerialize(path[v]);</span><br><span class="line">                    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    path[j].add(g.getEdge(v,j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getShortestPath</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(start+<span class="string">"到"</span>+end+<span class="string">"最短路径:"</span>);</span><br><span class="line">        <span class="keyword">for</span>(EdgeVector temp:path[end])&#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">"长度:"</span>);</span><br><span class="line">        System.out.printf(<span class="string">"%.3f"</span>,weight[end]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getShortestPath</span><span class="params">(<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        System.out.println(start+<span class="string">"到"</span>+end+<span class="string">"最短路径:"</span>);</span><br><span class="line">        <span class="keyword">for</span>(EdgeVector temp:path[end])&#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">"长度:"</span>);</span><br><span class="line">        System.out.printf(<span class="string">"%.3f"</span>,weight[end]);      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此,<code>Dijkstra</code>的 <del>复杂化</del> 实现就完成了(。Д。 ；)  </p><p><img src="http://p0s30qphu.bkt.clouddn.com/17-12-11/44899376.jpg" alt="jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面说到了使用 &lt;code&gt;Serializable&lt;/code&gt; 序列化来做有向图单源最短路径问题(Single Source Shortest Paths)中的路径复制问题,这次来说说处理最短路径的算法— &lt;code&gt;Dijkstra&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://delitto.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法" scheme="https://delitto.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Java" scheme="https://delitto.top/tags/Java/"/>
    
      <category term="学习笔记" scheme="https://delitto.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>编程杂谈(1)---Java序列化之使用Serializable</title>
    <link href="https://delitto.top/2017/11/25/talk1/"/>
    <id>https://delitto.top/2017/11/25/talk1/</id>
    <published>2017-11-25T05:38:57.290Z</published>
    <updated>2017-12-14T14:18:16.842Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>起因去年上数据结构的课，老师给了道求图的最短路径的题.  </p><p>可想而知得用了Dijkstra算法 (´･ω･｀)<br>但在路径复制的时候,因为我用<code>ArrayList</code>来存储路径,所以出现了复制之后改其中一个就导致其他复制的对象都改变的情况   </p><p>因为我是通过直接赋值来进行复制的，早就听闻Java中对于对象的赋值是属于浅拷贝<br>如果想要得到两个独立的对象,需要使用深拷贝(Deep Copy)<br>而实现深拷贝的方式有多种,当时找的时候图方便,就用了网上的一个通过序列化-反序列化进行深拷贝的方法  </p><p>代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList深拷贝</span></span><br><span class="line"><span class="comment"> * 采用的是序列化-反序列化的方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepCopy</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList <span class="title">copyBySerialize</span><span class="params">(ArrayList src)</span><span class="keyword">throws</span> IOException,ClassNotFoundException</span>&#123;</span><br><span class="line">        ByteArrayOutputStream byteOut = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(byteOut);</span><br><span class="line">        out.writeObject(src);</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream byteIn = <span class="keyword">new</span> ByteArrayInputStream(byteOut.toByteArray());</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(byteIn);</span><br><span class="line">        ArrayList dest = (ArrayList)in.readObject();</span><br><span class="line">        <span class="keyword">return</span> dest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当时乍一看,觉得好像没什么难点,就是变成数据流再从数据流读取<br>后来在Runoob上看到了<a href="http://www.runoob.com/java/java-serialization.html" target="_blank" rel="external">关于Java序列化的教程</a>,于是便来学习一番</p><h2 id="什么是序列化"><a href="#什么是序列化" class="headerlink" title="什么是序列化"></a>什么是序列化</h2><p>序列化指的是将一个对象表示为一个字节序列,该字节序列包含了该对象的数据,有关对象类型的信息和存储在对象中数据的类型<br>而通过序列化之后的字节序列是由JVM管理的,也就是不同平台上的字节序列不会出现“失真”这种情况  </p><h2 id="实现序列化"><a href="#实现序列化" class="headerlink" title="实现序列化"></a>实现序列化</h2><p>而实现序列化的方法很简单–使用类<a href="https://docs.oracle.com/javase/8/docs/api/java/io/ObjectInputStream.html" target="_blank" rel="external">ObjectInputStream</a>和<a href="https://docs.oracle.com/javase/8/docs/api/java/io/ObjectOutputStream.html" target="_blank" rel="external">ObjectOutputStream</a></p><p>使用<code>ObjectInputStream</code> 的 <code>writeObject()</code>方法将一个对象序列化<br>使用<code>ObjectOutputStream</code> 的 <code>readObject()</code>方法将一个对象反序列化</p><p>对于一个对象,该类必须实现 <code>java.io.Serializable</code> 接口,且该类的所有属性也必须是可序列化的,如果某个属性不可序列化,那么需要使用<code>transient</code> 关键字注明该属性是暂时的</p><h2 id="关于transient关键字"><a href="#关于transient关键字" class="headerlink" title="关于transient关键字"></a>关于transient关键字</h2><p>这个关键字用于标识你不需要序列化的变量,在序列化对象时,被<code>transient</code>关键字标注的变量不会被序列化到指定的目的地中</p><ul><li>一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问</li><li>transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口</li><li>被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化</li></ul><p>关于transient的更详细的说明可以参考<a href="http://www.cnblogs.com/lanxuezaipiao/p/3369962.html" target="_blank" rel="external">这个博文</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;起因去年上数据结构的课，老师给了道求图的最短路径的题.  &lt;/p&gt;
&lt;p&gt;可想而知得用了Dijkstra算法 (´･ω･｀)&lt;br&gt;但在路径
      
    
    </summary>
    
      <category term="编程" scheme="https://delitto.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="https://delitto.top/tags/Java/"/>
    
      <category term="学习笔记" scheme="https://delitto.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 102 and 107</title>
    <link href="https://delitto.top/2017/11/23/LeetCode102-and-107/"/>
    <id>https://delitto.top/2017/11/23/LeetCode102-and-107/</id>
    <published>2017-11-23T09:50:54.679Z</published>
    <updated>2017-12-14T14:17:55.712Z</updated>
    
    <content type="html"><![CDATA[<p>两道关于树的镜像题 <a id="more"></a><br><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/" target="_blank" rel="external">Binary Tree Level Order Traversal</a><br><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/description/" target="_blank" rel="external">Binary Tree Level Order Traversal II</a></p><h2 id="原题目"><a href="#原题目" class="headerlink" title="原题目"></a>原题目</h2><p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">For example:</span><br><span class="line">Given binary tree [3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line"><span class="built_in">return</span> its level order traversal as:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一颗二叉树,将其分解到二维数组中<br>102是自顶向下<br>107是自底向上</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>一开始我想用递归…但是总觉得不好做,这个怎么看都像一道求树的层次遍历的题<br>于是我便想到了BFS<br>用队列来做的话很简单<br>代码在<a href="https://github.com/Punizione/LeetCode/blob/master/%23102BFS.java" target="_blank" rel="external">这里</a>和<a href="https://github.com/Punizione/LeetCode/blob/master/%23107BFS.java" target="_blank" rel="external">这里</a></p><p>结果就不放出来了<br>意外的是运行时间竟然最快就也就2ms,仅仅beat 50%不到的人<br>而只需要1ms的是用递归的(´・ω・`)<br>但是我已经做不下去了233333<br>就不再进行什么优化了(逃</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;两道关于树的镜像题
    
    </summary>
    
      <category term="编程" scheme="https://delitto.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法" scheme="https://delitto.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://delitto.top/tags/LeetCode/"/>
    
      <category term="Java" scheme="https://delitto.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 617</title>
    <link href="https://delitto.top/2017/11/22/leetcode617/"/>
    <id>https://delitto.top/2017/11/22/leetcode617/</id>
    <published>2017-11-22T12:33:18.989Z</published>
    <updated>2017-12-14T14:17:37.140Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/merge-two-binary-trees/description/" target="_blank" rel="external">Merge Two Binary Trees</a></p><h2 id="原题目"><a href="#原题目" class="headerlink" title="原题目"></a>原题目</h2><p>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.</p><p>You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: </span><br><span class="line">    Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         / \                       / \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       /                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">Output: </span><br><span class="line">Merged tree:</span><br><span class="line">         3</span><br><span class="line">        / \</span><br><span class="line">       4   5</span><br><span class="line">      / \   \ </span><br><span class="line">     5   4   7</span><br></pre></td></tr></table></figure></p><p>Note: The merging process must start from the root nodes of both trees.</p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>合并两个二叉树为一棵新的二叉树,若两树中有共有节点则将节点值相加.</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>二叉树的题我的基本思路都会从递归开始<br>这道题已经给出了树的节点的结构<br>所以看到这道题第一时间我就想到了递归,if判断一下是否为空,不为空就相加<br>代码在<a href="https://github.com/Punizione/LeetCode/blob/master/%23617.java" target="_blank" rel="external">这里</a></p><p>运行结果如下<br><img src="http://p0s30qphu.bkt.clouddn.com/17-12-11/76585387.jpg" alt="01"></p><p>感觉比想象中的慢了一点,想再思考别的解决方案,但始终觉得递归已经是最快的了,如果用BFS或DFS会更慢,那到底是什么原因使得这串代码时间这么长呢?<br><img src="http://p0s30qphu.bkt.clouddn.com/17-12-11/13658034.jpg" alt="二叉懵逼"></p><p>再回去看代码,想想可能是if语句的问题?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>仔细一想的话还是下面这种的速度会比上面快(在递归栈里面)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>&#123; <span class="keyword">return</span> ; &#125;</span><br><span class="line"><span class="keyword">if</span>&#123; <span class="keyword">return</span> ; &#125;</span><br><span class="line"><span class="keyword">if</span>&#123; <span class="keyword">return</span> ; &#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br></pre></td></tr></table></figure><p>实际运行结果如下<br><img src="http://p0s30qphu.bkt.clouddn.com/17-12-11/542108.jpg" alt="02"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/merge-two-binary-trees/description/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Merge Two Binary Trees&lt;/a&gt;&lt;/p&gt;
      
    
    </summary>
    
      <category term="编程" scheme="https://delitto.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法" scheme="https://delitto.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://delitto.top/tags/LeetCode/"/>
    
      <category term="Java" scheme="https://delitto.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>蓬莱山辉夜</title>
    <link href="https://delitto.top/2017/11/21/kaguya/"/>
    <id>https://delitto.top/2017/11/21/kaguya/</id>
    <published>2017-11-21T10:06:31.314Z</published>
    <updated>2017-12-14T14:17:16.621Z</updated>
    
    <content type="html"><![CDATA[<p>来打架啊妹红！<a id="more"></a></p><h2 id="永遠と須臾の罪人"><a href="#永遠と須臾の罪人" class="headerlink" title="永遠と須臾の罪人"></a><a href="http://thwiki.cc/%E8%93%AC%E8%8E%B1%E5%B1%B1%E8%BE%89%E5%A4%9C" target="_blank" rel="external">永遠と須臾の罪人</a></h2><p><img src="http://p0s30qphu.bkt.clouddn.com/17-12-11/67844445.jpg" alt="原画"><br>说了妹红接下来说说辉夜，辉夜的人物设计取材于《竹取物语》,同时公主的角色曲也是改编自日本的童谣(?)-竹取飞翔,名为<a href="http://music.163.com/#/song?id=22636695" target="_blank" rel="external">竹取飞翔　～ Lunatic Princess</a>,前奏十分优美舒适,但节奏越来越快,使人感受到Lunatic的含义,公主的符卡设计得也很巧妙,从”五个难题”入手,从五色的弹丸,到佛御石,到火鼠的皮衣,到燕的子安贝,再到蓬莱的弹枝,单从符卡名称就能感受公主的狂气(笑)(≖ ‿ ≖)✧,更不用说返返返返返了….扭不过去啊（╯－＿－）╯╧╧</p><h2 id="上图时间"><a href="#上图时间" class="headerlink" title="上图时间"></a>上图时间</h2><p><img src="http://p0s30qphu.bkt.clouddn.com/17-12-11/97442560.jpg" alt="001"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=9020427" target="_blank" rel="external">Click Here</a></center><p><img src="http://p0s30qphu.bkt.clouddn.com/17-12-11/6311169.jpg" alt="002"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=12657794" target="_blank" rel="external">Click Here</a></center><p><img src="http://p0s30qphu.bkt.clouddn.com/17-12-11/13763298.jpg" alt="003"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=16237731" target="_blank" rel="external">Click Here</a></center><p><img src="http://p0s30qphu.bkt.clouddn.com/17-12-11/82391875.jpg" alt="004"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=31844315" target="_blank" rel="external">Click Here</a></center><p><img src="http://p0s30qphu.bkt.clouddn.com/17-12-11/8174365.jpg" alt="005"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=47649278" target="_blank" rel="external">Click Here</a></center><p><img src="http://p0s30qphu.bkt.clouddn.com/17-12-11/88958828.jpg" alt="006"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=49831115" target="_blank" rel="external">Click Here</a></center><p><img src="http://p0s30qphu.bkt.clouddn.com/17-12-11/15151607.jpg" alt="007"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=52053527" target="_blank" rel="external">Click Here</a></center><p><img src="http://p0s30qphu.bkt.clouddn.com/17-12-11/77063553.jpg" alt="008"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=62153079" target="_blank" rel="external">Click Here</a></center><p><img src="http://p0s30qphu.bkt.clouddn.com/17-12-11/11972384.jpg" alt="009"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=63242749" target="_blank" rel="external">Click Here</a></center><p><img src="http://p0s30qphu.bkt.clouddn.com/17-12-11/36288942.jpg" alt="010"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=64730960" target="_blank" rel="external">Click Here</a></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来打架啊妹红！
    
    </summary>
    
      <category term="闲聊" scheme="https://delitto.top/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="东方" scheme="https://delitto.top/tags/%E4%B8%9C%E6%96%B9/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 190 and 191</title>
    <link href="https://delitto.top/2017/11/20/leetcode-190-and-191/"/>
    <id>https://delitto.top/2017/11/20/leetcode-190-and-191/</id>
    <published>2017-11-20T09:44:49.785Z</published>
    <updated>2017-12-14T14:16:57.043Z</updated>
    
    <content type="html"><![CDATA[<p>没有什么问题是暴力破解不能解决的。 –鲁迅<a id="more"></a>  </p><p><a href="https://leetcode.com/problems/reverse-bits/description/" target="_blank" rel="external">Reverse Bits</a><br><a href="https://leetcode.com/problems/number-of-1-bits/description/" target="_blank" rel="external">Number of 1 Bits</a></p><h2 id="先说第一道"><a href="#先说第一道" class="headerlink" title="先说第一道"></a>先说第一道</h2><p>Reverse bits of a given 32 bits unsigned integer.</p><p>For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000).</p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>求32位无符号整型的二进制翻转后的结果对应的数</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>emm..我选择<a href="https://en.wikipedia.org/wiki/Brute-force_attack" target="_blank" rel="external">Brute-Force</a><br>用JDK自带函数强行转为二进制再补足32位再翻转再转换。。<br>原本以为会TimeLimited<br>结果居然Accepted了美滋滋 (=ﾟωﾟ)ﾉ<br>代码在<a href="https://github.com/Punizione/LeetCode/blob/master/%23190.java" target="_blank" rel="external">这里</a></p><h2 id="第二道"><a href="#第二道" class="headerlink" title="第二道"></a>第二道</h2><p>Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight).</p><p>For example, the 32-bit integer ’11’ has binary representation 00000000000000000000000000001011, so the function should return 3.</p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>求给定的整型的二进制编码中1的个数</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>emmm..运气真好竟然连续两道题都能用暴力破解<br>转换后一个循环..<br>代码在<a href="https://github.com/Punizione/LeetCode/blob/master/%23191.java" target="_blank" rel="external">这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;没有什么问题是暴力破解不能解决的。 –鲁迅
    
    </summary>
    
      <category term="编程" scheme="https://delitto.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法" scheme="https://delitto.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://delitto.top/tags/LeetCode/"/>
    
      <category term="Java" scheme="https://delitto.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>藤原妹红</title>
    <link href="https://delitto.top/2017/11/17/mokou/"/>
    <id>https://delitto.top/2017/11/17/mokou/</id>
    <published>2017-11-17T09:59:16.768Z</published>
    <updated>2017-12-14T14:16:37.045Z</updated>
    
    <content type="html"><![CDATA[<p>爷们红! ⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄.<a id="more"></a></p><h2 id="蓬莱の人の形"><a href="#蓬莱の人の形" class="headerlink" title="蓬莱の人の形"></a><a href="http://thwiki.cc/%E8%97%A4%E5%8E%9F%E5%A6%B9%E7%BA%A2" target="_blank" rel="external">蓬莱の人の形</a></h2><p><img src="http://p0s30qphu.bkt.clouddn.com/17-12-11/19255687.jpg" alt="001"><br>妹红可以说是永夜抄里最喜欢的角色了，从她那打不死的体质与无限复活的非符，霸气的灭罪寺院伤、正直者之死、[虚人]无一这几张卡让初见的我欲罢不能⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄<br>角色歌是有名的 <del>乒乓</del> 神曲 <a href="http://music.163.com/#/song?id=22636687" target="_blank" rel="external">月まで届け、不死の煙</a></p><h2 id="上图时间"><a href="#上图时间" class="headerlink" title="上图时间"></a>上图时间</h2><p><img src="http://p0s30qphu.bkt.clouddn.com/17-12-11/79811919.jpg" alt="000"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=32760601" target="_blank" rel="external">Click Here</a></center><p><img src="http://p0s30qphu.bkt.clouddn.com/17-12-11/73225533.jpg" alt="002"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=34074398" target="_blank" rel="external">Click Here</a></center><p><img src="http://p0s30qphu.bkt.clouddn.com/17-12-11/57888635.jpg" alt="003"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=37533949" target="_blank" rel="external">Click Here</a></center><p><img src="http://p0s30qphu.bkt.clouddn.com/17-12-11/65174949.jpg" alt="004"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=39533537" target="_blank" rel="external">Click Here</a></center><p><img src="http://p0s30qphu.bkt.clouddn.com/17-12-11/65272613.jpg" alt="005"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=41264142" target="_blank" rel="external">Click Here</a></center><p><img src="http://p0s30qphu.bkt.clouddn.com/17-12-11/12601188.jpg" alt="006"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=45350924" target="_blank" rel="external">Click Here</a></center><p><img src="http://p0s30qphu.bkt.clouddn.com/17-12-11/29669291.jpg" alt="007"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=63228582" target="_blank" rel="external">Click Here</a></center><p><img src="http://p0s30qphu.bkt.clouddn.com/17-12-11/4159082.jpg" alt="009"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=65546923" target="_blank" rel="external">Click Here</a></center><p><img src="http://p0s30qphu.bkt.clouddn.com/17-12-11/17850705.jpg" alt="010"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=65783237" target="_blank" rel="external">Click Here</a></center><p><img src="http://p0s30qphu.bkt.clouddn.com/17-12-11/74241915.jpg" alt="008"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=64675587" target="_blank" rel="external">Click Here</a></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;爷们红! ⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄.
    
    </summary>
    
      <category term="闲聊" scheme="https://delitto.top/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="东方" scheme="https://delitto.top/tags/%E4%B8%9C%E6%96%B9/"/>
    
  </entry>
  
</feed>
