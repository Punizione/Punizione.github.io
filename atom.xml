<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Punizione&#39;s Blog</title>
  
  <subtitle>吃,喝,玩,打代码</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-11-25T06:34:56.540Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Delitto</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>编程杂谈(1)---Java序列化之使用Serializable</title>
    <link href="http://yoursite.com/2017/11/25/talk1/"/>
    <id>http://yoursite.com/2017/11/25/talk1/</id>
    <published>2017-11-25T05:38:57.290Z</published>
    <updated>2017-11-25T06:34:56.540Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>起因去年上数据结构的课，老师给了道求图的最短路径的题.  </p><p>可想而知得用了Dijkstra算法 (´･ω･｀)<br>但在路径复制的时候,因为我用<code>ArrayList</code>来存储路径,所以出现了复制之后改其中一个就导致其他复制的对象都改变的情况   </p><p>因为我是通过直接赋值来进行复制的，早就听闻Java中对于对象的赋值是属于浅拷贝<br>如果想要得到两个独立的对象,需要使用深拷贝(Deep Copy)<br>而实现深拷贝的方式有多种,当时找的时候图方便,就用了网上的一个通过序列化-反序列化进行深拷贝的方法  </p><p>代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList深拷贝</span></span><br><span class="line"><span class="comment"> * 采用的是序列化-反序列化的方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepCopy</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList <span class="title">copyBySerialize</span><span class="params">(ArrayList src)</span><span class="keyword">throws</span> IOException,ClassNotFoundException</span>&#123;</span><br><span class="line">        ByteArrayOutputStream byteOut = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(byteOut);</span><br><span class="line">        out.writeObject(src);</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream byteIn = <span class="keyword">new</span> ByteArrayInputStream(byteOut.toByteArray());</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(byteIn);</span><br><span class="line">        ArrayList dest = (ArrayList)in.readObject();</span><br><span class="line">        <span class="keyword">return</span> dest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当时乍一看,觉得好像没什么难点,就是变成数据流再从数据流读取<br>后来在Runoob上看到了<a href="http://www.runoob.com/java/java-serialization.html" target="_blank" rel="external">关于Java序列化的教程</a>,于是便来学习一番</p><h2 id="什么是序列化"><a href="#什么是序列化" class="headerlink" title="什么是序列化"></a>什么是序列化</h2><p>序列化指的是将一个对象表示为一个字节序列,该字节序列包含了该对象的数据,有关对象类型的信息和存储在对象中数据的类型<br>而通过序列化之后的字节序列是由JVM管理的,也就是不同平台上的字节序列不会出现“失真”这种情况  </p><h2 id="实现序列化"><a href="#实现序列化" class="headerlink" title="实现序列化"></a>实现序列化</h2><p>而实现序列化的方法很简单–使用类<a href="https://docs.oracle.com/javase/8/docs/api/java/io/ObjectInputStream.html" target="_blank" rel="external">ObjectInputStream</a>和<a href="https://docs.oracle.com/javase/8/docs/api/java/io/ObjectOutputStream.html" target="_blank" rel="external">ObjectOutputStream</a></p><p>使用<code>ObjectInputStream</code> 的 <code>writeObject()</code>方法将一个对象序列化<br>使用<code>ObjectOutputStream</code> 的 <code>readObject()</code>方法将一个对象反序列化</p><p>对于一个对象,该类必须实现 <code>java.io.Serializable</code> 接口,且该类的所有属性也必须是可序列化的,如果某个属性不可序列化,那么需要使用<code>transient</code> 关键字注明该属性是暂时的</p><h2 id="关于transient关键字"><a href="#关于transient关键字" class="headerlink" title="关于transient关键字"></a>关于transient关键字</h2><p>这个关键字用于标识你不需要序列化的变量,在序列化对象时,被<code>transient</code>关键字标注的变量不会被序列化到指定的目的地中</p><ul><li>一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问</li><li>transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口</li><li>被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化</li></ul><p>关于transient的更详细的说明可以参考<a href="http://www.cnblogs.com/lanxuezaipiao/p/3369962.html" target="_blank" rel="external">这个博文</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;起因去年上数据结构的课，老师给了道求图的最短路径的题.  &lt;/p&gt;
&lt;p&gt;可想而知得用了Dijkstra算法 (´･ω･｀)&lt;br&gt;但在路径
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 102 and 107</title>
    <link href="http://yoursite.com/2017/11/23/LeetCode102-and-107/"/>
    <id>http://yoursite.com/2017/11/23/LeetCode102-and-107/</id>
    <published>2017-11-23T09:50:54.679Z</published>
    <updated>2017-11-23T10:02:27.887Z</updated>
    
    <content type="html"><![CDATA[<p>两道关于树的镜像题 <a id="more"></a><br><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/" target="_blank" rel="external">Binary Tree Level Order Traversal</a><br><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/description/" target="_blank" rel="external">Binary Tree Level Order Traversal II</a></p><h2 id="原题目"><a href="#原题目" class="headerlink" title="原题目"></a>原题目</h2><p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">For example:</span><br><span class="line">Given binary tree [3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line"><span class="built_in">return</span> its level order traversal as:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一颗二叉树,将其分解到二维数组中<br>102是自顶向下<br>107是自底向上</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>一开始我想用递归…但是总觉得不好做,这个怎么看都像一道求树的层次遍历的题<br>于是我便想到了BFS<br>用队列来做的话很简单<br>代码在<a href="https://github.com/Punizione/LeetCode/blob/master/%23102BFS.java" target="_blank" rel="external">这里</a>和<a href="https://github.com/Punizione/LeetCode/blob/master/%23107BFS.java" target="_blank" rel="external">这里</a></p><p>结果就不放出来了<br>意外的是运行时间竟然最快就也就2ms,仅仅beat 50%不到的人<br>而只需要1ms的是用递归的(´・ω・`)<br>但是我已经做不下去了233333<br>就不再进行什么优化了(逃</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;两道关于树的镜像题
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 617</title>
    <link href="http://yoursite.com/2017/11/22/leetcode617/"/>
    <id>http://yoursite.com/2017/11/22/leetcode617/</id>
    <published>2017-11-22T12:33:18.989Z</published>
    <updated>2017-11-22T13:06:21.868Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/merge-two-binary-trees/description/" target="_blank" rel="external">Merge Two Binary Trees</a></p><h2 id="原题目"><a href="#原题目" class="headerlink" title="原题目"></a>原题目</h2><p>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.</p><p>You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: </span><br><span class="line">    Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         / \                       / \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       /                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">Output: </span><br><span class="line">Merged tree:</span><br><span class="line">         3</span><br><span class="line">        / \</span><br><span class="line">       4   5</span><br><span class="line">      / \   \ </span><br><span class="line">     5   4   7</span><br></pre></td></tr></table></figure></p><p>Note: The merging process must start from the root nodes of both trees.</p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>合并两个二叉树为一棵新的二叉树,若两树中有共有节点则将节点值相加.</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>二叉树的题我的基本思路都会从递归开始<br>这道题已经给出了树的节点的结构<br>所以看到这道题第一时间我就想到了递归,if判断一下是否为空,不为空就相加<br>代码在<a href="https://github.com/Punizione/LeetCode/blob/master/%23617.java" target="_blank" rel="external">这里</a></p><p>运行结果如下<br><img src="/css/images/617-1.png" alt="01"></p><p>感觉比想象中的慢了一点,想再思考别的解决方案,但始终觉得递归已经是最快的了,如果用BFS或DFS会更慢,那到底是什么原因使得这串代码时间这么长呢?<br><img src="/css/images/mengbi.jpg" alt="二叉懵逼"></p><p>再回去看代码,想想可能是if语句的问题?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>仔细一想的话还是下面这种的速度会比上面快(在递归栈里面)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>&#123; <span class="keyword">return</span> ; &#125;</span><br><span class="line"><span class="keyword">if</span>&#123; <span class="keyword">return</span> ; &#125;</span><br><span class="line"><span class="keyword">if</span>&#123; <span class="keyword">return</span> ; &#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br></pre></td></tr></table></figure><p>实际运行结果如下<br><img src="/css/images/617-2.png" alt="02"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/merge-two-binary-trees/description/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Merge Two Binary Trees&lt;/a&gt;&lt;/p&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>蓬莱山辉夜</title>
    <link href="http://yoursite.com/2017/11/21/kaguya/"/>
    <id>http://yoursite.com/2017/11/21/kaguya/</id>
    <published>2017-11-21T10:06:31.314Z</published>
    <updated>2017-11-21T10:30:18.472Z</updated>
    
    <content type="html"><![CDATA[<p>来打架啊妹红！<a id="more"></a></p><h2 id="永遠と須臾の罪人"><a href="#永遠と須臾の罪人" class="headerlink" title="永遠と須臾の罪人"></a><a href="http://thwiki.cc/%E8%93%AC%E8%8E%B1%E5%B1%B1%E8%BE%89%E5%A4%9C" target="_blank" rel="external">永遠と須臾の罪人</a></h2><p><img src="/css/images/kaguya/000.png" alt="原画"><br>说了妹红接下来说说辉夜，辉夜的人物设计取材于《竹取物语》,同时公主的角色曲也是改编自日本的童谣(?)-竹取飞翔,名为<a href="http://music.163.com/#/song?id=22636695" target="_blank" rel="external">竹取飞翔　～ Lunatic Princess</a>,前奏十分优美舒适,但节奏越来越快,使人感受到Lunatic的含义,公主的符卡设计得也很巧妙,从”五个难题”入手,从五色的弹丸,到佛御石,到火鼠的皮衣,到燕的子安贝,再到蓬莱的弹枝,单从符卡名称就能感受公主的狂气(笑)(≖ ‿ ≖)✧,更不用说永夜返了….扭不过去啊（╯－＿－）╯╧╧</p><h2 id="上图时间"><a href="#上图时间" class="headerlink" title="上图时间"></a>上图时间</h2><p><img src="/css/images/kaguya/001.jpg" alt="001"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=9020427" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/kaguya/002.jpg" alt="002"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=12657794" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/kaguya/003.jpg" alt="003"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=16237731" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/kaguya/004.jpg" alt="004"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=31844315" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/kaguya/005.jpg" alt="005"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=47649278" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/kaguya/006.jpg" alt="006"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=49831115" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/kaguya/007.jpg" alt="007"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=52053527" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/kaguya/008.jpg" alt="008"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=62153079" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/kaguya/009.jpg" alt="009"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=63242749" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/kaguya/010.jpg" alt="010"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=64730960" target="_blank" rel="external">Click Here</a></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来打架啊妹红！
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 190 and 191</title>
    <link href="http://yoursite.com/2017/11/20/leetcode-190-and-191/"/>
    <id>http://yoursite.com/2017/11/20/leetcode-190-and-191/</id>
    <published>2017-11-20T09:44:49.785Z</published>
    <updated>2017-11-22T13:04:19.061Z</updated>
    
    <content type="html"><![CDATA[<p>没有什么问题是暴力破解不能解决的。 –鲁迅<a id="more"></a>  </p><p><a href="https://leetcode.com/problems/reverse-bits/description/" target="_blank" rel="external">Reverse Bits</a><br><a href="https://leetcode.com/problems/number-of-1-bits/description/" target="_blank" rel="external">Number of 1 Bits</a></p><h2 id="先说第一道"><a href="#先说第一道" class="headerlink" title="先说第一道"></a>先说第一道</h2><p>Reverse bits of a given 32 bits unsigned integer.</p><p>For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000).</p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>求32位无符号整型的二进制翻转后的结果对应的数</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>emm..我选择<a href="https://en.wikipedia.org/wiki/Brute-force_attack" target="_blank" rel="external">Brute-Force</a><br>用JDK自带函数强行转为二进制再补足32位再翻转再转换。。<br>原本以为会TimeLimited<br>结果居然Accepted了美滋滋 (=ﾟωﾟ)ﾉ<br>代码在<a href="https://github.com/Punizione/LeetCode/blob/master/%23190.java" target="_blank" rel="external">这里</a></p><h2 id="第二道"><a href="#第二道" class="headerlink" title="第二道"></a>第二道</h2><p>Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight).</p><p>For example, the 32-bit integer ’11’ has binary representation 00000000000000000000000000001011, so the function should return 3.</p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>求给定的整型的二进制编码中1的个数</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>emmm..运气真好竟然连续两道题都能用暴力破解<br>转换后一个循环..<br>代码在<a href="https://github.com/Punizione/LeetCode/blob/master/%23191.java" target="_blank" rel="external">这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;没有什么问题是暴力破解不能解决的。 –鲁迅
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>藤原妹红</title>
    <link href="http://yoursite.com/2017/11/17/mokou/"/>
    <id>http://yoursite.com/2017/11/17/mokou/</id>
    <published>2017-11-17T09:59:16.768Z</published>
    <updated>2017-11-17T10:28:06.140Z</updated>
    
    <content type="html"><![CDATA[<p>爷们红! ⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄.<a id="more"></a></p><h2 id="蓬莱の人の形"><a href="#蓬莱の人の形" class="headerlink" title="蓬莱の人の形"></a><a href="http://thwiki.cc/%E8%97%A4%E5%8E%9F%E5%A6%B9%E7%BA%A2" target="_blank" rel="external">蓬莱の人の形</a></h2><p><img src="/css/images/mokou/001.png" alt="001"><br>妹红可以说是永夜抄里最喜欢的角色了，从她那打不死的体质与无限复活的非符，霸气的灭罪寺院伤、正直者之死、[虚人]无一这几张卡让初见的我欲罢不能⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄<br>角色歌是有名的 <del>乒乓</del> 神曲 <a href="http://music.163.com/#/song?id=22636687" target="_blank" rel="external">月まで届け、不死の煙</a></p><h2 id="上图时间"><a href="#上图时间" class="headerlink" title="上图时间"></a>上图时间</h2><p><img src="/css/images/mokou/000.jpg" alt="000"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=32760601" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/mokou/002.jpg" alt="002"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=34074398" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/mokou/003.jpg" alt="003"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=37533949" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/mokou/004.jpg" alt="004"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=39533537" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/mokou/005.jpg" alt="005"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=41264142" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/mokou/006.jpg" alt="006"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=45350924" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/mokou/007.jpg" alt="007"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=63228582" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/mokou/009.jpg" alt="009"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=65546923" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/mokou/010.jpg" alt="010"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=65783237" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/mokou/008.jpg" alt="008"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=64675587" target="_blank" rel="external">Click Here</a></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;爷们红! ⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 214</title>
    <link href="http://yoursite.com/2017/11/15/LeetCode214/"/>
    <id>http://yoursite.com/2017/11/15/LeetCode214/</id>
    <published>2017-11-15T04:53:03.441Z</published>
    <updated>2017-11-22T13:03:15.956Z</updated>
    
    <content type="html"><![CDATA[<p><strong>这是一道 <del>送命题</del> 送分题  (´･ω･｀)</strong><br><a id="more"></a>  </p><p><a href="https://leetcode.com/problems/shortest-palindrome/description/" target="_blank" rel="external">Shortest Palindrome</a></p><h2 id="原题目"><a href="#原题目" class="headerlink" title="原题目"></a>原题目</h2><p>Given a string S, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">For example:</span><br><span class="line"></span><br><span class="line">Given <span class="string">"aacecaaa"</span>, <span class="built_in">return</span> <span class="string">"aaacecaaa"</span>.</span><br><span class="line"></span><br><span class="line">Given <span class="string">"abcd"</span>, <span class="built_in">return</span> <span class="string">"dcbabcd"</span>.</span><br></pre></td></tr></table></figure><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个字符串，在这个字符串前加一些字符，使得这个字符串变成回文字符串，要求所加的字符最少。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>自己接触的第一道Hard的题，第一感觉不是很难<br>思路是令一个指针从字符串最后一位开始往前走，循环判断指针前的字符串是否是回文，是的话则将指针后的字符反过来加到原字符串前面，不是的话指针接着往前走，思路上感觉没什么问题。代码实现在<a href="https://github.com/Punizione/LeetCode/blob/master/%23214TimeLimited.java" target="_blank" rel="external">这里</a>.运行结果是TimeLimited…. ( ・◇・)？</p><p>猜测是在循环里判断是否是回文花费了太多时间<br>后来想了想，应该需要两个指针，头指针用来标记已经是回文的那一部分，用递归来拼接字符串。<br>代码在<a href="https://github.com/Punizione/LeetCode/blob/master/%23214.java" target="_blank" rel="external">这里</a><br>运行结果如下<br><img src="/css/images/214.png" alt="214"></p><p>大功告成!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;这是一道 &lt;del&gt;送命题&lt;/del&gt; 送分题  (´･ω･｀)&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 1</title>
    <link href="http://yoursite.com/2017/11/14/leetcode1/"/>
    <id>http://yoursite.com/2017/11/14/leetcode1/</id>
    <published>2017-11-14T12:53:35.111Z</published>
    <updated>2017-11-22T13:03:34.082Z</updated>
    
    <content type="html"><![CDATA[<p>从这里开始陆陆续续把缓慢刷LeetCode的过程记录上来 (´・ω・`)  <a id="more"></a></p><p><a href="https://leetcode.com/problems/two-sum/description/" target="_blank" rel="external">Two Sum</a></p><h2 id="原题目"><a href="#原题目" class="headerlink" title="原题目"></a>原题目</h2><blockquote><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.<br>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class="line"><span class="built_in">return</span> [0, 1].</span><br></pre></td></tr></table></figure><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个整形数组，找到两个数加起来的和等于给定的一个数  </p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这是道Easy难度的题，感觉没有必要做得很夸张 _(:3 」∠)_<br>一开始我的思路是直接暴力求解<br>然后差点就TimeLimited了….<br>代码在<a href="https://github.com/Punizione/LeetCode/blob/master/%231.java" target="_blank" rel="external">这里</a><br>后来想想..先排个序然后头指针+尾指针一起向中间走就是了<br>但是运行时间还是有点长，于是考虑另外的方法，<br>想了想能比排序更快的大概用Map可以解决<br>于是改成了HashMap的版本<br>改了后代码在<a href="https://github.com/Punizione/LeetCode/blob/master/%231Better.java" target="_blank" rel="external">这里</a><br>运行结果<br><img src="/css/images/1.png" alt="result"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从这里开始陆陆续续把缓慢刷LeetCode的过程记录上来 (´・ω・`)
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>假的第一次博客</title>
    <link href="http://yoursite.com/2017/11/13/new-post/"/>
    <id>http://yoursite.com/2017/11/13/new-post/</id>
    <published>2017-11-13T09:35:58.407Z</published>
    <updated>2017-11-14T13:15:42.569Z</updated>
    
    <content type="html"><![CDATA[<p>新的开始啦!\(￣▽￣)/<br><a id="more"></a></p><h2 id="为什么想做这个东西"><a href="#为什么想做这个东西" class="headerlink" title="为什么想做这个东西 "></a>为什么想做这个东西 </h2><p>其实老早就有做博客的想法了，15年底的时候听说腾讯云有个学生优惠云主机的活动，当时就去弄了认证，建了一个临时站点，无奈前端技术不过关，捣腾许久也没能做出自己想要的效果。  </p><p>最早做有博客想法的是 <a href="https://github.com/MyStringIsNotNull" target="_blank" rel="external">剑锋Dalao</a>，在<a href="http://blog.csdn.net/MyStringIsNotNull" target="_blank" rel="external">CSDN</a>上陆陆续续发表了很多自己心得，当时觉得自己也是有一大堆想法和点子想要记录下来，于是就在那台1个月1块钱的主机上记录了两个多月的博文，<del>然后那台云主机就被黑掉了</del>  </p><p>痛苦的地方在于没有保存副本，想来也不是很重要的文章，也就算了，<del>找不回来了我也很绝望啊</del>  </p><p>做这个博客是前阵子想导出TG的贴纸，搜了一下就找到了一位dalao-<a href="https://blog.phoenixlzx.com/" target="_blank" rel="external">Phoenixlzx</a>的<a href="https://blog.phoenixlzx.com/2016/08/23/my-first-yet-useless-telegram-bot/" target="_blank" rel="external">文章</a>和<a href="https://github.com/phoenixlzx/telegram-stickerimage-bot" target="_blank" rel="external">demo</a>  </p><p>大概翻看了一下，<del>竟然是PHP写的，</del>在dalao的指引下又去找到TG官方的文档，然而</p><blockquote><p>搜索了一下现成客户端的源码，都是交给 MTProto 的 API 处理，也没有明确的解析过程。而这些客户端所调用的 messages.getStickerSet 也没有在官方的文档中列出。（吐槽：Telegram 的协议、文档和代码真是糟糕，查阅的时候我的表情一直是 黑人问号.gif</p></blockquote><p><img src="/css/images/006HJgYYgy1fhxrz3v19xg304t04m3yp.gif" alt="你TM在逗我">  </p><p>回到正题，发现dalao的博客用的是Hexo，试着做了一会感觉就是我以前想要做的效果，以前怎么没有发现有这东西(ノ=Д=)ノ┻━┻  </p><p>于是乎就开始更新博客了…<br>内容嘛暂时就聊聊代码，东方，克苏鲁，SCP基金会等等..<br>怕是坑开太多填不了<del>flag</del></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新的开始啦!\(￣▽￣)/&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
