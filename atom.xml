<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Punizione&#39;s Blog</title>
  
  <subtitle>吃,喝,玩,打代码</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-11-27T11:00:54.308Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Delitto</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>编程杂谈(2)---Java有向图单源最短路径之Dijkstra算法</title>
    <link href="http://yoursite.com/2017/11/27/Dijkstra/"/>
    <id>http://yoursite.com/2017/11/27/Dijkstra/</id>
    <published>2017-11-27T10:02:58.217Z</published>
    <updated>2017-11-27T11:00:54.308Z</updated>
    
    <content type="html"><![CDATA[<p>前面说到了使用 <code>Serializable</code> 序列化来做有向图单源最短路径问题(Single Source Shortest Paths)中的路径复制问题,这次来说说处理最短路径的算法— <code>Dijkstra</code><br><a id="more"></a></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>为了解决有向图的单元最短路径问题,我们先来定义一些结构,当然,不使用额外定义的结构,只是用数组来表示点,边,图也是可以的,这里为了方便理解就使用结构  </p><p>首先是图的边类 <code>EdgeVector</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EdgeVector</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">EdgeVector</span>&gt;,<span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> weight;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  start  有向边起点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  end    有向边终点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  weight 权重</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>        </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EdgeVector</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">double</span> weight)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">weight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">end</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(EdgeVector that)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.weight() &lt; that.weight())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.weight() &gt; that.weight())&#123;</span><br><span class="line">            <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"%d-&gt;%d (%.2f)"</span>, start, end, weight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 <code>Comparable</code> 是为了方便对两条边进行权重比较  </p><p>同时注意到,这里用了整型来表示顶点,这么做也是为了方便理解,在给出的一个图G中,每个顶点由特有的定点编号确定,这里就不采用英文字母作为编号了  </p><p>其次,是图的类 <code>GraphVector</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphVector</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> V;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> E;</span><br><span class="line">    <span class="keyword">private</span> MyBag&lt;EdgeVector&gt;[] adj;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(value=&#123;<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GraphVector</span><span class="params">(<span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.V = V;</span><br><span class="line">        <span class="keyword">this</span>.E = <span class="number">0</span>;</span><br><span class="line">        adj = (MyBag&lt;EdgeVector&gt;[]) <span class="keyword">new</span> MyBag[<span class="keyword">this</span>.V];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V;i++)&#123;</span><br><span class="line">            adj[i] = <span class="keyword">new</span> MyBag&lt;EdgeVector&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(value=&#123;<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GraphVector</span><span class="params">(BufferedReader reader)</span></span>&#123;</span><br><span class="line">        String lineTxt;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>((lineTxt = reader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.V = Integer.parseInt(lineTxt);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"文件输入格式不规范"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((lineTxt = reader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>.E = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            adj = (MyBag&lt;EdgeVector&gt;[])<span class="keyword">new</span> MyBag[V];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;V;i++)&#123;</span><br><span class="line">                adj[i] = <span class="keyword">new</span> MyBag&lt;EdgeVector&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>((lineTxt = reader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                String[] temp = lineTxt.split(<span class="string">" "</span>);</span><br><span class="line">                <span class="keyword">this</span>.addEdge(<span class="keyword">new</span> EdgeVector(Integer.parseInt(temp[<span class="number">0</span>]), Integer.parseInt(temp[<span class="number">1</span>]), Double.parseDouble(temp[<span class="number">2</span>])));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">V</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">E</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.E;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(EdgeVector e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = e.start();</span><br><span class="line">        adj[start].add(e);</span><br><span class="line">        E++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;EdgeVector&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> adj[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;EdgeVector&gt; <span class="title">edges</span><span class="params">()</span></span>&#123;</span><br><span class="line">        MyBag&lt;EdgeVector&gt; bag = <span class="keyword">new</span> MyBag&lt;EdgeVector&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;V;v++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(EdgeVector temp:adj[v])&#123;</span><br><span class="line">                bag.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> EdgeVector <span class="title">getEdge</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        EdgeVector edge = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(EdgeVector temp:adj[start])&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.end() == end)&#123;</span><br><span class="line">                edge  = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">            edge = <span class="keyword">new</span> EdgeVector(-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(edge==<span class="keyword">null</span>)&#123;</span><br><span class="line">            edge = <span class="keyword">new</span> EdgeVector(-<span class="number">1</span>,-<span class="number">1</span>,Double.POSITIVE_INFINITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> edge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>图的实现主要使用了背包 <code>Bag</code> 的数组来保存图中的所有边,也可以使用二维数组的,但是数组的长度不好确定,所以这里我就用了 <code>Bag</code>  </p><p>用来保存边集的背包类 <code>Bag</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBag</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    Node&lt;T&gt; first;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBag</span><span class="params">()</span></span>&#123;</span><br><span class="line">        first = <span class="keyword">new</span> Node&lt;T&gt;();</span><br><span class="line">        length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBag</span><span class="params">(T[] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        <span class="keyword">for</span>(T temp:array)&#123;</span><br><span class="line">            <span class="keyword">this</span>.add(<span class="keyword">new</span> Node&lt;T&gt;(temp));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node&lt;T&gt; node)</span></span>&#123;</span><br><span class="line">        node.next = first.next;</span><br><span class="line">        first.next = node;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">        Node&lt;T&gt; node = <span class="keyword">new</span> Node&lt;T&gt;(data);</span><br><span class="line">        node.next = first.next;</span><br><span class="line">        first.next = node;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//  return this.first.next==null;</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.length==<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node&lt;T&gt; current = first.next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (current != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">            T data = current.data;</span><br><span class="line">            current = current.next;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuffer str = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        Node&lt;T&gt; p = first;</span><br><span class="line">        <span class="keyword">while</span>(p.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            str.append(p.next.toString()+<span class="string">" "</span>);</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了方便以后在别的地方使用 <code>Bag</code> 类,这里用了泛型实现,而且实现了 <code>Iterable</code> 接口进行迭代,这是为了方便在对定起点的边进行搜索时进行迭代</p><p>注意到 <code>Bag</code> 的实现还使用了 <code>Node</code> , <code>Node</code>表示节点,可以在很多题目上使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Object</span>&gt;</span>&#123;</span><br><span class="line">    T data;</span><br><span class="line">    Node&lt;T&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.next =<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>+<span class="keyword">this</span>.data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至此,实现 <code>Dijkstra</code> 所需要的结构都有了<br>我也把代码放到Github上了,需要的自取</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>首先把图的点V集分成两个集合A,B  </p><p>A表示已经在最短路径里面的顶点,初始化包含起点<br>B表示不在最短路径里面的顶点,即V-A  </p><p>循环开始, 每次把集合A与集合B中相连的边按递增次序获取, 取到最短的边,并将终点从B中删除,加入到A中,<br>每次增加新的边后要刷新一遍A,因为可能出现<code>v0 -&gt; v1</code>的权重比<code>v0 -&gt; v2 -&gt; v1</code>大的情况  </p><p>如此循环反复,最终得到的便是单源到图其他顶点的最短路径  </p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">class Dijkstra&#123;</span><br><span class="line">    //无限大</span><br><span class="line">    public static double INFINITY = Double.POSITIVE_INFINITY;</span><br><span class="line">    //表示由起点(start)到各个点的最短路径的权重</span><br><span class="line">    private double[] weight;</span><br><span class="line">    //保存由起点(start)到各个点的最短路径边</span><br><span class="line">    private ArrayList&lt;EdgeVector&gt;[] path;</span><br><span class="line"></span><br><span class="line">    private int start;</span><br><span class="line">    private int end;</span><br><span class="line">    //因为使用了泛型数组的初始化</span><br><span class="line">    //编译器会报&quot;未经检查的类型警告&quot;</span><br><span class="line">    @SuppressWarnings(value=&#123;&quot;unchecked&quot;&#125;)</span><br><span class="line">    public Dijkstra(GraphVector g,int start,int end)&#123;</span><br><span class="line">        //初始化</span><br><span class="line">        this.start = start;</span><br><span class="line">        this.end = end;</span><br><span class="line">        weight = new double[g.V()];</span><br><span class="line">        for(int i=0;i&lt;g.V();i++)&#123;</span><br><span class="line">            weight[i] = INFINITY;</span><br><span class="line">        &#125;</span><br><span class="line">        weight[start] = 0.0;</span><br><span class="line">        for(EdgeVector temp:g.adj(start))&#123;</span><br><span class="line">            weight[temp.end()] = temp.weight();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        path = (ArrayList&lt;EdgeVector&gt;[])new ArrayList[g.V()];</span><br><span class="line">        for(int i=0;i&lt;g.V();i++)&#123;</span><br><span class="line">            path[i] = new ArrayList&lt;EdgeVector&gt;();</span><br><span class="line">            if(g.getEdge(start,i).weight()&lt; INFINITY)&#123;</span><br><span class="line">                //把起点 与 起点可达连通的点 形成的边保存为最短路径</span><br><span class="line">                path[i].add(g.getEdge(start,i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean[] hasFindPath = new boolean[g.V()];</span><br><span class="line">        for(int i=0;i&lt;g.V();i++)&#123;</span><br><span class="line">            hasFindPath[i] = false;</span><br><span class="line">        &#125;</span><br><span class="line">        hasFindPath[start] = true;</span><br><span class="line"></span><br><span class="line">        //开始循环</span><br><span class="line">        int v = -1;</span><br><span class="line">        for(int i=0;i&lt;g.V();i++)&#123;</span><br><span class="line">            double min = INFINITY;</span><br><span class="line">            for(int j=0;j&lt;g.V();j++)&#123;</span><br><span class="line">                if( !hasFindPath[j] )&#123;</span><br><span class="line">                    if(weight[j] &lt; min)&#123;</span><br><span class="line">                        v = j;</span><br><span class="line">                        min = weight[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            hasFindPath[v] = true;</span><br><span class="line">        </span><br><span class="line">            for(int j = 0;j&lt;g.V();j++)&#123;</span><br><span class="line">                if(!hasFindPath[j] &amp;&amp; (g.getEdge(v,j).weight() &lt; INFINITY) &amp;&amp; (min+g.getEdge(v,j).weight() &lt; weight[j]))&#123;</span><br><span class="line">                    weight[j] = min+g.getEdge(v,j).weight();</span><br><span class="line">                    try&#123;</span><br><span class="line">                        //这里采用的是深拷贝</span><br><span class="line">                        //实现方式见类DeepCopy</span><br><span class="line">                        path[j] = (ArrayList&lt;EdgeVector&gt;)DeepCopy.copyBySerialize(path[v]);</span><br><span class="line">                    &#125;catch(Exception e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    path[j].add(g.getEdge(v,j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void getShortestPath()&#123;</span><br><span class="line">        System.out.println(start+&quot;到&quot;+end+&quot;最短路径:&quot;);</span><br><span class="line">        for(EdgeVector temp:path[end])&#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;长度:&quot;);</span><br><span class="line">        System.out.printf(&quot;%.3f&quot;,weight[end]);</span><br><span class="line">    &#125;</span><br><span class="line">    public void getShortestPath(int end)&#123;</span><br><span class="line">        System.out.println(start+&quot;到&quot;+end+&quot;最短路径:&quot;);</span><br><span class="line">        for(EdgeVector temp:path[end])&#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(&quot;长度:&quot;);</span><br><span class="line">        System.out.printf(&quot;%.3f&quot;,weight[end]);      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此,<code>Dijkstra</code>的 <del>复杂化</del> 实现就完成了(。Д。 ；)  </p><p><img src="./css/images/55527150_p0_master1200.jpg" alt="jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面说到了使用 &lt;code&gt;Serializable&lt;/code&gt; 序列化来做有向图单源最短路径问题(Single Source Shortest Paths)中的路径复制问题,这次来说说处理最短路径的算法— &lt;code&gt;Dijkstra&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>编程杂谈(1)---Java序列化之使用Serializable</title>
    <link href="http://yoursite.com/2017/11/25/talk1/"/>
    <id>http://yoursite.com/2017/11/25/talk1/</id>
    <published>2017-11-25T05:38:57.290Z</published>
    <updated>2017-11-25T06:41:42.091Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>起因去年上数据结构的课，老师给了道求图的最短路径的题.  </p><p>可想而知得用了Dijkstra算法 (´･ω･｀)<br>但在路径复制的时候,因为我用<code>ArrayList</code>来存储路径,所以出现了复制之后改其中一个就导致其他复制的对象都改变的情况   </p><p>因为我是通过直接赋值来进行复制的，早就听闻Java中对于对象的赋值是属于浅拷贝<br>如果想要得到两个独立的对象,需要使用深拷贝(Deep Copy)<br>而实现深拷贝的方式有多种,当时找的时候图方便,就用了网上的一个通过序列化-反序列化进行深拷贝的方法  </p><p>代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ArrayList深拷贝</span></span><br><span class="line"><span class="comment"> * 采用的是序列化-反序列化的方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepCopy</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList <span class="title">copyBySerialize</span><span class="params">(ArrayList src)</span><span class="keyword">throws</span> IOException,ClassNotFoundException</span>&#123;</span><br><span class="line">        ByteArrayOutputStream byteOut = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(byteOut);</span><br><span class="line">        out.writeObject(src);</span><br><span class="line"></span><br><span class="line">        ByteArrayInputStream byteIn = <span class="keyword">new</span> ByteArrayInputStream(byteOut.toByteArray());</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(byteIn);</span><br><span class="line">        ArrayList dest = (ArrayList)in.readObject();</span><br><span class="line">        <span class="keyword">return</span> dest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当时乍一看,觉得好像没什么难点,就是变成数据流再从数据流读取<br>后来在Runoob上看到了<a href="http://www.runoob.com/java/java-serialization.html" target="_blank" rel="external">关于Java序列化的教程</a>,于是便来学习一番</p><h2 id="什么是序列化"><a href="#什么是序列化" class="headerlink" title="什么是序列化"></a>什么是序列化</h2><p>序列化指的是将一个对象表示为一个字节序列,该字节序列包含了该对象的数据,有关对象类型的信息和存储在对象中数据的类型<br>而通过序列化之后的字节序列是由JVM管理的,也就是不同平台上的字节序列不会出现“失真”这种情况  </p><h2 id="实现序列化"><a href="#实现序列化" class="headerlink" title="实现序列化"></a>实现序列化</h2><p>而实现序列化的方法很简单–使用类<a href="https://docs.oracle.com/javase/8/docs/api/java/io/ObjectInputStream.html" target="_blank" rel="external">ObjectInputStream</a>和<a href="https://docs.oracle.com/javase/8/docs/api/java/io/ObjectOutputStream.html" target="_blank" rel="external">ObjectOutputStream</a></p><p>使用<code>ObjectInputStream</code> 的 <code>writeObject()</code>方法将一个对象序列化<br>使用<code>ObjectOutputStream</code> 的 <code>readObject()</code>方法将一个对象反序列化</p><p>对于一个对象,该类必须实现 <code>java.io.Serializable</code> 接口,且该类的所有属性也必须是可序列化的,如果某个属性不可序列化,那么需要使用<code>transient</code> 关键字注明该属性是暂时的</p><h2 id="关于transient关键字"><a href="#关于transient关键字" class="headerlink" title="关于transient关键字"></a>关于transient关键字</h2><p>这个关键字用于标识你不需要序列化的变量,在序列化对象时,被<code>transient</code>关键字标注的变量不会被序列化到指定的目的地中</p><ul><li>一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问</li><li>transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口</li><li>被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化</li></ul><p>关于transient的更详细的说明可以参考<a href="http://www.cnblogs.com/lanxuezaipiao/p/3369962.html" target="_blank" rel="external">这个博文</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;起因去年上数据结构的课，老师给了道求图的最短路径的题.  &lt;/p&gt;
&lt;p&gt;可想而知得用了Dijkstra算法 (´･ω･｀)&lt;br&gt;但在路径
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 102 and 107</title>
    <link href="http://yoursite.com/2017/11/23/LeetCode102-and-107/"/>
    <id>http://yoursite.com/2017/11/23/LeetCode102-and-107/</id>
    <published>2017-11-23T09:50:54.679Z</published>
    <updated>2017-11-23T10:02:27.887Z</updated>
    
    <content type="html"><![CDATA[<p>两道关于树的镜像题 <a id="more"></a><br><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/" target="_blank" rel="external">Binary Tree Level Order Traversal</a><br><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/description/" target="_blank" rel="external">Binary Tree Level Order Traversal II</a></p><h2 id="原题目"><a href="#原题目" class="headerlink" title="原题目"></a>原题目</h2><p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">For example:</span><br><span class="line">Given binary tree [3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line"><span class="built_in">return</span> its level order traversal as:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一颗二叉树,将其分解到二维数组中<br>102是自顶向下<br>107是自底向上</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>一开始我想用递归…但是总觉得不好做,这个怎么看都像一道求树的层次遍历的题<br>于是我便想到了BFS<br>用队列来做的话很简单<br>代码在<a href="https://github.com/Punizione/LeetCode/blob/master/%23102BFS.java" target="_blank" rel="external">这里</a>和<a href="https://github.com/Punizione/LeetCode/blob/master/%23107BFS.java" target="_blank" rel="external">这里</a></p><p>结果就不放出来了<br>意外的是运行时间竟然最快就也就2ms,仅仅beat 50%不到的人<br>而只需要1ms的是用递归的(´・ω・`)<br>但是我已经做不下去了233333<br>就不再进行什么优化了(逃</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;两道关于树的镜像题
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 617</title>
    <link href="http://yoursite.com/2017/11/22/leetcode617/"/>
    <id>http://yoursite.com/2017/11/22/leetcode617/</id>
    <published>2017-11-22T12:33:18.989Z</published>
    <updated>2017-11-22T13:06:21.868Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/merge-two-binary-trees/description/" target="_blank" rel="external">Merge Two Binary Trees</a></p><h2 id="原题目"><a href="#原题目" class="headerlink" title="原题目"></a>原题目</h2><p>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.</p><p>You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: </span><br><span class="line">    Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         / \                       / \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       /                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">Output: </span><br><span class="line">Merged tree:</span><br><span class="line">         3</span><br><span class="line">        / \</span><br><span class="line">       4   5</span><br><span class="line">      / \   \ </span><br><span class="line">     5   4   7</span><br></pre></td></tr></table></figure></p><p>Note: The merging process must start from the root nodes of both trees.</p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>合并两个二叉树为一棵新的二叉树,若两树中有共有节点则将节点值相加.</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>二叉树的题我的基本思路都会从递归开始<br>这道题已经给出了树的节点的结构<br>所以看到这道题第一时间我就想到了递归,if判断一下是否为空,不为空就相加<br>代码在<a href="https://github.com/Punizione/LeetCode/blob/master/%23617.java" target="_blank" rel="external">这里</a></p><p>运行结果如下<br><img src="/css/images/617-1.png" alt="01"></p><p>感觉比想象中的慢了一点,想再思考别的解决方案,但始终觉得递归已经是最快的了,如果用BFS或DFS会更慢,那到底是什么原因使得这串代码时间这么长呢?<br><img src="/css/images/mengbi.jpg" alt="二叉懵逼"></p><p>再回去看代码,想想可能是if语句的问题?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>仔细一想的话还是下面这种的速度会比上面快(在递归栈里面)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>&#123; <span class="keyword">return</span> ; &#125;</span><br><span class="line"><span class="keyword">if</span>&#123; <span class="keyword">return</span> ; &#125;</span><br><span class="line"><span class="keyword">if</span>&#123; <span class="keyword">return</span> ; &#125;</span><br><span class="line"><span class="keyword">return</span> ;</span><br></pre></td></tr></table></figure><p>实际运行结果如下<br><img src="/css/images/617-2.png" alt="02"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/merge-two-binary-trees/description/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Merge Two Binary Trees&lt;/a&gt;&lt;/p&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>蓬莱山辉夜</title>
    <link href="http://yoursite.com/2017/11/21/kaguya/"/>
    <id>http://yoursite.com/2017/11/21/kaguya/</id>
    <published>2017-11-21T10:06:31.314Z</published>
    <updated>2017-11-21T10:30:18.472Z</updated>
    
    <content type="html"><![CDATA[<p>来打架啊妹红！<a id="more"></a></p><h2 id="永遠と須臾の罪人"><a href="#永遠と須臾の罪人" class="headerlink" title="永遠と須臾の罪人"></a><a href="http://thwiki.cc/%E8%93%AC%E8%8E%B1%E5%B1%B1%E8%BE%89%E5%A4%9C" target="_blank" rel="external">永遠と須臾の罪人</a></h2><p><img src="/css/images/kaguya/000.png" alt="原画"><br>说了妹红接下来说说辉夜，辉夜的人物设计取材于《竹取物语》,同时公主的角色曲也是改编自日本的童谣(?)-竹取飞翔,名为<a href="http://music.163.com/#/song?id=22636695" target="_blank" rel="external">竹取飞翔　～ Lunatic Princess</a>,前奏十分优美舒适,但节奏越来越快,使人感受到Lunatic的含义,公主的符卡设计得也很巧妙,从”五个难题”入手,从五色的弹丸,到佛御石,到火鼠的皮衣,到燕的子安贝,再到蓬莱的弹枝,单从符卡名称就能感受公主的狂气(笑)(≖ ‿ ≖)✧,更不用说永夜返了….扭不过去啊（╯－＿－）╯╧╧</p><h2 id="上图时间"><a href="#上图时间" class="headerlink" title="上图时间"></a>上图时间</h2><p><img src="/css/images/kaguya/001.jpg" alt="001"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=9020427" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/kaguya/002.jpg" alt="002"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=12657794" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/kaguya/003.jpg" alt="003"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=16237731" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/kaguya/004.jpg" alt="004"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=31844315" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/kaguya/005.jpg" alt="005"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=47649278" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/kaguya/006.jpg" alt="006"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=49831115" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/kaguya/007.jpg" alt="007"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=52053527" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/kaguya/008.jpg" alt="008"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=62153079" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/kaguya/009.jpg" alt="009"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=63242749" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/kaguya/010.jpg" alt="010"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=64730960" target="_blank" rel="external">Click Here</a></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来打架啊妹红！
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 190 and 191</title>
    <link href="http://yoursite.com/2017/11/20/leetcode-190-and-191/"/>
    <id>http://yoursite.com/2017/11/20/leetcode-190-and-191/</id>
    <published>2017-11-20T09:44:49.785Z</published>
    <updated>2017-11-22T13:04:19.061Z</updated>
    
    <content type="html"><![CDATA[<p>没有什么问题是暴力破解不能解决的。 –鲁迅<a id="more"></a>  </p><p><a href="https://leetcode.com/problems/reverse-bits/description/" target="_blank" rel="external">Reverse Bits</a><br><a href="https://leetcode.com/problems/number-of-1-bits/description/" target="_blank" rel="external">Number of 1 Bits</a></p><h2 id="先说第一道"><a href="#先说第一道" class="headerlink" title="先说第一道"></a>先说第一道</h2><p>Reverse bits of a given 32 bits unsigned integer.</p><p>For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000).</p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>求32位无符号整型的二进制翻转后的结果对应的数</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>emm..我选择<a href="https://en.wikipedia.org/wiki/Brute-force_attack" target="_blank" rel="external">Brute-Force</a><br>用JDK自带函数强行转为二进制再补足32位再翻转再转换。。<br>原本以为会TimeLimited<br>结果居然Accepted了美滋滋 (=ﾟωﾟ)ﾉ<br>代码在<a href="https://github.com/Punizione/LeetCode/blob/master/%23190.java" target="_blank" rel="external">这里</a></p><h2 id="第二道"><a href="#第二道" class="headerlink" title="第二道"></a>第二道</h2><p>Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight).</p><p>For example, the 32-bit integer ’11’ has binary representation 00000000000000000000000000001011, so the function should return 3.</p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>求给定的整型的二进制编码中1的个数</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>emmm..运气真好竟然连续两道题都能用暴力破解<br>转换后一个循环..<br>代码在<a href="https://github.com/Punizione/LeetCode/blob/master/%23191.java" target="_blank" rel="external">这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;没有什么问题是暴力破解不能解决的。 –鲁迅
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>藤原妹红</title>
    <link href="http://yoursite.com/2017/11/17/mokou/"/>
    <id>http://yoursite.com/2017/11/17/mokou/</id>
    <published>2017-11-17T09:59:16.768Z</published>
    <updated>2017-11-17T10:28:06.140Z</updated>
    
    <content type="html"><![CDATA[<p>爷们红! ⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄.<a id="more"></a></p><h2 id="蓬莱の人の形"><a href="#蓬莱の人の形" class="headerlink" title="蓬莱の人の形"></a><a href="http://thwiki.cc/%E8%97%A4%E5%8E%9F%E5%A6%B9%E7%BA%A2" target="_blank" rel="external">蓬莱の人の形</a></h2><p><img src="/css/images/mokou/001.png" alt="001"><br>妹红可以说是永夜抄里最喜欢的角色了，从她那打不死的体质与无限复活的非符，霸气的灭罪寺院伤、正直者之死、[虚人]无一这几张卡让初见的我欲罢不能⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄<br>角色歌是有名的 <del>乒乓</del> 神曲 <a href="http://music.163.com/#/song?id=22636687" target="_blank" rel="external">月まで届け、不死の煙</a></p><h2 id="上图时间"><a href="#上图时间" class="headerlink" title="上图时间"></a>上图时间</h2><p><img src="/css/images/mokou/000.jpg" alt="000"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=32760601" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/mokou/002.jpg" alt="002"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=34074398" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/mokou/003.jpg" alt="003"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=37533949" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/mokou/004.jpg" alt="004"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=39533537" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/mokou/005.jpg" alt="005"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=41264142" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/mokou/006.jpg" alt="006"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=45350924" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/mokou/007.jpg" alt="007"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=63228582" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/mokou/009.jpg" alt="009"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=65546923" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/mokou/010.jpg" alt="010"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=65783237" target="_blank" rel="external">Click Here</a></center><p><img src="/css/images/mokou/008.jpg" alt="008"></p><center><a href="https://www.pixiv.net/member_illust.php?mode=medium&amp;illust_id=64675587" target="_blank" rel="external">Click Here</a></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;爷们红! ⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 214</title>
    <link href="http://yoursite.com/2017/11/15/LeetCode214/"/>
    <id>http://yoursite.com/2017/11/15/LeetCode214/</id>
    <published>2017-11-15T04:53:03.441Z</published>
    <updated>2017-11-22T13:03:15.956Z</updated>
    
    <content type="html"><![CDATA[<p><strong>这是一道 <del>送命题</del> 送分题  (´･ω･｀)</strong><br><a id="more"></a>  </p><p><a href="https://leetcode.com/problems/shortest-palindrome/description/" target="_blank" rel="external">Shortest Palindrome</a></p><h2 id="原题目"><a href="#原题目" class="headerlink" title="原题目"></a>原题目</h2><p>Given a string S, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">For example:</span><br><span class="line"></span><br><span class="line">Given <span class="string">"aacecaaa"</span>, <span class="built_in">return</span> <span class="string">"aaacecaaa"</span>.</span><br><span class="line"></span><br><span class="line">Given <span class="string">"abcd"</span>, <span class="built_in">return</span> <span class="string">"dcbabcd"</span>.</span><br></pre></td></tr></table></figure><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个字符串，在这个字符串前加一些字符，使得这个字符串变成回文字符串，要求所加的字符最少。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>自己接触的第一道Hard的题，第一感觉不是很难<br>思路是令一个指针从字符串最后一位开始往前走，循环判断指针前的字符串是否是回文，是的话则将指针后的字符反过来加到原字符串前面，不是的话指针接着往前走，思路上感觉没什么问题。代码实现在<a href="https://github.com/Punizione/LeetCode/blob/master/%23214TimeLimited.java" target="_blank" rel="external">这里</a>.运行结果是TimeLimited…. ( ・◇・)？</p><p>猜测是在循环里判断是否是回文花费了太多时间<br>后来想了想，应该需要两个指针，头指针用来标记已经是回文的那一部分，用递归来拼接字符串。<br>代码在<a href="https://github.com/Punizione/LeetCode/blob/master/%23214.java" target="_blank" rel="external">这里</a><br>运行结果如下<br><img src="/css/images/214.png" alt="214"></p><p>大功告成!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;这是一道 &lt;del&gt;送命题&lt;/del&gt; 送分题  (´･ω･｀)&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LeetCode 1</title>
    <link href="http://yoursite.com/2017/11/14/leetcode1/"/>
    <id>http://yoursite.com/2017/11/14/leetcode1/</id>
    <published>2017-11-14T12:53:35.111Z</published>
    <updated>2017-11-22T13:03:34.082Z</updated>
    
    <content type="html"><![CDATA[<p>从这里开始陆陆续续把缓慢刷LeetCode的过程记录上来 (´・ω・`)  <a id="more"></a></p><p><a href="https://leetcode.com/problems/two-sum/description/" target="_blank" rel="external">Two Sum</a></p><h2 id="原题目"><a href="#原题目" class="headerlink" title="原题目"></a>原题目</h2><blockquote><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.<br>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class="line"><span class="built_in">return</span> [0, 1].</span><br></pre></td></tr></table></figure><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个整形数组，找到两个数加起来的和等于给定的一个数  </p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这是道Easy难度的题，感觉没有必要做得很夸张 _(:3 」∠)_<br>一开始我的思路是直接暴力求解<br>然后差点就TimeLimited了….<br>代码在<a href="https://github.com/Punizione/LeetCode/blob/master/%231.java" target="_blank" rel="external">这里</a><br>后来想想..先排个序然后头指针+尾指针一起向中间走就是了<br>但是运行时间还是有点长，于是考虑另外的方法，<br>想了想能比排序更快的大概用Map可以解决<br>于是改成了HashMap的版本<br>改了后代码在<a href="https://github.com/Punizione/LeetCode/blob/master/%231Better.java" target="_blank" rel="external">这里</a><br>运行结果<br><img src="/css/images/1.png" alt="result"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从这里开始陆陆续续把缓慢刷LeetCode的过程记录上来 (´・ω・`)
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>假的第一次博客</title>
    <link href="http://yoursite.com/2017/11/13/new-post/"/>
    <id>http://yoursite.com/2017/11/13/new-post/</id>
    <published>2017-11-13T09:35:58.407Z</published>
    <updated>2017-11-14T13:15:42.569Z</updated>
    
    <content type="html"><![CDATA[<p>新的开始啦!\(￣▽￣)/<br><a id="more"></a></p><h2 id="为什么想做这个东西"><a href="#为什么想做这个东西" class="headerlink" title="为什么想做这个东西 "></a>为什么想做这个东西 </h2><p>其实老早就有做博客的想法了，15年底的时候听说腾讯云有个学生优惠云主机的活动，当时就去弄了认证，建了一个临时站点，无奈前端技术不过关，捣腾许久也没能做出自己想要的效果。  </p><p>最早做有博客想法的是 <a href="https://github.com/MyStringIsNotNull" target="_blank" rel="external">剑锋Dalao</a>，在<a href="http://blog.csdn.net/MyStringIsNotNull" target="_blank" rel="external">CSDN</a>上陆陆续续发表了很多自己心得，当时觉得自己也是有一大堆想法和点子想要记录下来，于是就在那台1个月1块钱的主机上记录了两个多月的博文，<del>然后那台云主机就被黑掉了</del>  </p><p>痛苦的地方在于没有保存副本，想来也不是很重要的文章，也就算了，<del>找不回来了我也很绝望啊</del>  </p><p>做这个博客是前阵子想导出TG的贴纸，搜了一下就找到了一位dalao-<a href="https://blog.phoenixlzx.com/" target="_blank" rel="external">Phoenixlzx</a>的<a href="https://blog.phoenixlzx.com/2016/08/23/my-first-yet-useless-telegram-bot/" target="_blank" rel="external">文章</a>和<a href="https://github.com/phoenixlzx/telegram-stickerimage-bot" target="_blank" rel="external">demo</a>  </p><p>大概翻看了一下，<del>竟然是PHP写的，</del>在dalao的指引下又去找到TG官方的文档，然而</p><blockquote><p>搜索了一下现成客户端的源码，都是交给 MTProto 的 API 处理，也没有明确的解析过程。而这些客户端所调用的 messages.getStickerSet 也没有在官方的文档中列出。（吐槽：Telegram 的协议、文档和代码真是糟糕，查阅的时候我的表情一直是 黑人问号.gif</p></blockquote><p><img src="/css/images/006HJgYYgy1fhxrz3v19xg304t04m3yp.gif" alt="你TM在逗我">  </p><p>回到正题，发现dalao的博客用的是Hexo，试着做了一会感觉就是我以前想要做的效果，以前怎么没有发现有这东西(ノ=Д=)ノ┻━┻  </p><p>于是乎就开始更新博客了…<br>内容嘛暂时就聊聊代码，东方，克苏鲁，SCP基金会等等..<br>怕是坑开太多填不了<del>flag</del></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新的开始啦!\(￣▽￣)/&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
